<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Java 集合框架『1』 | icetea</title>
  <meta name="author" content="icetea">
  
  <meta name="description" content="本文引用自pdai.tech《Java 集合框架》 作者：@pdai，">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java 集合框架『1』"/>
  <meta property="og:site_name" content="icetea"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 5.4.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">icetea</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Java 集合框架『1』</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> 本文引用自pdai.tech《Java 集合框架》 作者：@pdai，
		 </div> <!-- alert -->
	  		

	  <p>Collection 接口的接口 对象的集合（单列集合）<br>├——-List 接口：元素按进入先后有序保存，可重复<br>│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-└ Vector 接口实现类 数组， 同步， 线程安全<br>│ ———————-└ Stack 是Vector类的实现类（不建议使用）<br>└——-Set 接口： 仅接收一次，不可重复，并做内部排序<br>├—————-└HashSet 使用hash表（数组）存储元素<br>│————————└ LinkedHashSet 链表维护元素的插入次序<br>└ —————-TreeSet 底层实现为二叉树，元素排好序</p>
<span id="more"></span>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>​    容器，就是可以容纳其他Java对象的对象。<code>Java Collections Framework(JCF)</code>为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:降低编程难度，提高程序性能，提高API间的互操作性，降低学习难度，降低设计和实现相关API的难度，增加程序的重用性。</p>
<p>​    Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><blockquote>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p>
</blockquote>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 详情见Java 集合框架 （2）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。详情见Java 集合框架 （2）</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。详情见Java 集合框架 （2）</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​    <code>ArrayList</code>实现了<code>List</code>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<code>数组实现</code>。除该类未实现同步外，其余跟<code>Vector</code>大致相同。每个<code>ArrayList</code>都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add(), addAll()</td>
<td align="center">这两个方法都是向容器中添加新元素，这可能会导致<code>capacity</code>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。</td>
</tr>
<tr>
<td align="center">set()</td>
<td align="center">既然底层是一个数组<code>ArrayList</code>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。</td>
</tr>
<tr>
<td align="center">get()</td>
<td align="center"><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center"><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</td>
</tr>
<tr>
<td align="center">trimToSize()</td>
<td align="center">ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过<code>trimToSize</code>方法来实现。</td>
</tr>
<tr>
<td align="center">indexOf(), lastIndexOf()</td>
<td align="center">获取元素的第一次或最后一次出现的index:</td>
</tr>
</tbody></table>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>和 ArrayList 类似，但它是线程安全的。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​    LinkedList同时实现了<code>List</code>接口和<code>Deque</code>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<code>Queue</code>)，同时又可以看作一个栈(<code>Stack</code>)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用<code>Stack</code>类，更遗憾的是，Java里根本没有一个叫做<code>Queue</code>的类(它是个接口名字)。关于栈或队列，现在的首选是<code>ArrayDeque</code>，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...))</span><br></pre></td></tr></table></figure>

<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getFirst(), getLast()</td>
<td align="center">获取第一个元素， 和获取最后一个元素:</td>
</tr>
<tr>
<td align="center">removeFirest(), removeLast(), remove(e), remove(index)</td>
<td align="center"><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</td>
</tr>
<tr>
<td align="center">add()</td>
<td align="center"><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在LinkedList的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</td>
</tr>
<tr>
<td align="center">addAll()</td>
<td align="center">addAll(index, c) 实现方式<code>并不是直接调用add(index,e)来实现</code>，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</td>
</tr>
<tr>
<td align="center">indexOf</td>
<td align="center">查找操作的本质是查找元素的下标:查找第一次出现的index, 如果找不到返回-1；</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>​    Java里有一个叫做<code>Stack</code>的类，却没有叫做<code>Queue</code>的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用<code>Stack</code>，而是推荐使用更高效的<code>ArrayDeque</code>；既然<code>Queue</code>只是一个接口，当需要使用队列时也就首选<code>ArrayDeque</code>了(次选是<code>LinkedList</code>)。</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code>接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Returns special value</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>First Element - Head</th>
<th></th>
<th>Last Element - Tail</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Throws exception</td>
<td>Special value</td>
<td>Throws exception</td>
<td>Special value</td>
</tr>
<tr>
<td>Insert</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>Examine</td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下:</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
</tr>
</thead>
<tbody><tr>
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p><code>Deque</code>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<code>Deque</code>与<code>Queue</code>相对应的接口:</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>add(e)</td>
<td>addLast(e)</td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
<td>向队尾插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
<td>获取并删除队首元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
<td>获取但不删除队首元素，失败则返回<code>null</code></td>
</tr>
</tbody></table>
<p>下表列出了<code>Deque</code>与<code>Stack</code>对应的接口:</p>
<table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)</td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>offerFirst(e)</td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>pollFirst()</td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody></table>
<p>上面两个表共定义了<code>Deque</code>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然<code>Deque</code>的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p>
<p><code>ArrayDeque</code>和<code>LinkedList</code>是<code>Deque</code>的两个通用实现，由于官方更推荐使用<code>AarryDeque</code>用作栈和队列，加之上一篇已经讲解过<code>LinkedList</code>，本文将着重讲解<code>ArrayDeque</code>的具体实现。</p>
<p>从名字可以看出<code>ArrayDeque</code>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<code>循环数组(circular array)</code>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p>
<p><img src="https://img.doge.sh.cn/assets/163895659551771ZnQfDc.png" alt="ArrayDeque_base.png"></p>
<p>上图中我们看到，<code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>​    前面以Java <code>ArrayDeque</code>为例讲解了<code>Stack</code>和<code>Queue</code>，其实还有一种特殊的队列叫做<code>PriorityQueue</code>，即优先队列。优先队列的作用是能保证每次取出的元素都是<code>队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)</code>。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p>
<p>Java中<code>PriorityQueue</code>实现了<code>Queue</code>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为<code>PriorityQueue</code>的底层实现。</p>
<p><img src="https://img.doge.sh.cn/assets/16389567813097kKhxKZa.png" alt="PriorityQueue_base.png"></p>
<p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo = parentNo*2+1</span><br><span class="line">rightNo = parentNo*2+2</span><br><span class="line">parentNo = (nodeNo-1)/2</span><br></pre></td></tr></table></figure>

<p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p>
<p><code>PriorityQueue</code>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<code>log(N)</code>。</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add()和offer()</td>
<td align="center"><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于PriorityQueue这两个方法其实没什么差别。</td>
</tr>
<tr>
<td align="center">element()和peek()</td>
<td align="center"><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<code>直接返回数组0下标处的那个元素即可</code>。</td>
</tr>
<tr>
<td align="center">remove()和poll()</td>
<td align="center"><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</td>
</tr>
<tr>
<td align="center">remove(Object o)</td>
<td align="center"><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素(如果有多个相等，只删除一个)，该方法不是<code>Queue</code>接口内的方法，而是<code>Collection</code>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2021/12/10/Java-集合框架-『2』/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2021/10/13/IDEA-Linux-远程调试/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2021-12-03 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/Java/">Java<span>4</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Java/">Java<span>4</span></a></li> <li><a href="/tags/转载/">转载<span>4</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-article-text">介绍</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Collection"><span class="toc-article-text">Collection</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Set"><span class="toc-article-text">Set</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TreeSet"><span class="toc-article-text">TreeSet</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#HashSet"><span class="toc-article-text">HashSet</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#LinkedHashSet"><span class="toc-article-text">LinkedHashSet</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#List"><span class="toc-article-text">List</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ArrayList"><span class="toc-article-text">ArrayList</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-article-text">概述</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-article-text">常用方法</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Vector"><span class="toc-article-text">Vector</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#LinkedList"><span class="toc-article-text">LinkedList</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-article-text">概述</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-article-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Stack-amp-Queue"><span class="toc-article-text">Stack &amp; Queue</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-article-text">概述</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Queue"><span class="toc-article-text">Queue</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Deque"><span class="toc-article-text">Deque</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#PriorityQueue"><span class="toc-article-text">PriorityQueue</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-article-text">概述</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-article-text">常用方法</span></a></li></ol></li></ol></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2023 icetea
  
      with help from <a>Hexo</a>,<a>Freemind</a>,<a>Twitter Bootstrap</a> and <a>BOOTSTRA.386</a>. 
     <br> Theme by <a>Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
