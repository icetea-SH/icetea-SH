<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Centos 常用命令</title>
      <link href="/2022/05/03/Centos-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/03/Centos-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/2022/04/03/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/03/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>​    Docker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker基于LXC来实现类似VM的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同VM等虚拟化的方式不同，LXC不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。</p><p>Docker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。</p><p>Docker借助Linux的内核特性，如：控制组（Control Group）、命名空间（Namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。</p><span id="more"></span><p><img src="https://img.doge.sh.cn/assets/1687850699078iijRDhJ1.svg" alt="img"></p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p><p>下面我们来学 1、管理和使用本地 Docker 主机镜像 2、创建镜像</p><h3 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h3><p>我们可以使用 docker images 来列出本地主机上的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br><span class="line">hello-world         latest              fce289e99eb9        13 months ago       1.84kB</span><br></pre></td></tr></table></figure><p>各个选项说明:</p><ul><li>REPOSITORY：表示镜像的仓库源</li><li>TAG：镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><blockquote><p>以查找MySQL的镜像为例：</p></blockquote><ul><li><strong>通过Docker Hub 进行查找</strong>, 比如<a href="https://hub.docker.com/search?q=mysql&type=image">https://hub.docker.com/search?q=mysql&amp;type=image</a></li></ul><p><img src="https://img.doge.sh.cn/assets/16878507837628r624zAs.png" alt="img"></p><ul><li><strong>使用 docker search 命令来搜索镜像</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@pdai ~]<span class="comment"># docker search mysql</span></span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   9132                [OK]</span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3233                [OK]</span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   676                                     [OK]</span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   68</span><br><span class="line">mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   62</span><br><span class="line">centurylink/mysql                 Image containing mysql. Optimized to be link…   61                                      [OK]</span><br><span class="line">deitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                                      [OK]</span><br><span class="line">bitnami/mysql                     Bitnami MySQL Docker Image                      35                                      [OK]</span><br><span class="line">tutum/mysql                       Base docker image to run a MySQL database se…   34</span><br><span class="line">schickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   29                                      [OK]</span><br><span class="line">prom/mysqld-exporter                                                              26                                      [OK]</span><br><span class="line">linuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   24</span><br><span class="line">centos/mysql-56-centos7           MySQL 5.6 SQL database server                   19</span><br><span class="line">circleci/mysql                    MySQL is a widely used, open-source relation…   18</span><br><span class="line">mysql/mysql-router                MySQL Router provides transparent routing be…   14</span><br><span class="line">arey/mysql-client                 Run a MySQL client from a docker container      13                                      [OK]</span><br><span class="line">databack/mysql-backup             Back up mysql databases to... anywhere!         10</span><br><span class="line">openshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6</span><br><span class="line">fradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   5                                       [OK]</span><br><span class="line">genschsa/mysql-employees          MySQL Employee Sample Database                  4                                       [OK]</span><br><span class="line">devilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   2</span><br><span class="line">ansibleplaybookbundle/mysql-apb   An APB <span class="built_in">which</span> deploys RHSCL MySQL                2                                       [OK]</span><br><span class="line">jelastic/mysql                    An image of the MySQL database server mainta…   1</span><br><span class="line">monasca/mysql-init                A minimal decoupled init container <span class="keyword">for</span> mysql    0</span><br><span class="line">widdpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   0                                       [OK]</span><br></pre></td></tr></table></figure><ul><li>NAME: 镜像仓库源的名称</li><li>DESCRIPTION: 镜像的描述</li><li>OFFICIAL: 是否 docker 官方发布</li><li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li><li>AUTOMATED: 自动构建。</li></ul><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><blockquote><p>现在拉取搜索出的MySQL</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker pull mysql</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">619014d83c02: Pull complete</span><br><span class="line">9ced578c3a5f: Pull complete</span><br><span class="line">731f6e13d8ea: Pull complete</span><br><span class="line">3c183de42679: Pull complete</span><br><span class="line">6de69b5c2f3c: Pull complete</span><br><span class="line">00f0a4086406: Pull complete</span><br><span class="line">84d93aea836d: Pull complete</span><br><span class="line">f18efbfd8d76: Pull complete</span><br><span class="line">012b302865d1: Pull complete</span><br><span class="line">fe16fd240f59: Pull complete</span><br><span class="line">ca3e793e545e: Pull complete</span><br><span class="line">51d0f2cb2610: Pull complete</span><br><span class="line">Digest: sha256:6d0741319b6a2ae22c384a97f4bbee411b01e75f6284af0cce339fee83d7e314</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest</span><br><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mysql               latest              791b6e40940c        2 weeks ago         465MB</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br><span class="line">hello-world         latest              fce289e99eb9        13 months ago       1.84kB</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><blockquote><p>是时候删除那个无聊的hello-world镜像了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker rmi hello-world</span></span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference <span class="string">&quot;hello-world&quot;</span> (must force) - container c91b90b18884 is using its referenced image fce289e99eb9</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>发现报错了，这时候主要看两点：要么就是container实例存在，要么存在镜像依赖；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">1a51d2f023c9        ubuntu:latest       <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   2 hours ago         Exited (137) 2 hours ago                       gifted_brown</span><br><span class="line">414bf796cbe4        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              2 hours ago         Exited (0) 2 hours ago                         pedantic_galileo</span><br><span class="line">512061ebfa4c        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              2 hours ago         Exited (0) 2 hours ago                         wizardly_brown</span><br><span class="line">aa5e9ae5e5db        ubuntu:latest       <span class="string">&quot;/bin/echo &#x27;Hello wo…&quot;</span>   2 hours ago         Exited (0) 2 hours ago                         affectionate_knuth</span><br><span class="line">c91b90b18884        hello-world         <span class="string">&quot;/hello&quot;</span>                 3 hours ago         Exited (0) 3 hours ago                         admiring_pare</span><br><span class="line">[root@pdai ~]<span class="comment"># docker image inspect --format=&#x27;&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;&#x27; $(docker image ls -q )</span></span><br><span class="line">[mysql:latest] sha256:791b6e40940cd550af522eb4ffe995226798204504fe495743445b900e417a51</span><br><span class="line">[ubuntu:latest] sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0</span><br><span class="line">[hello-world:latest] sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e</span><br></pre></td></tr></table></figure><p>显然，我们只要删除container即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker rm c91b90b18884</span></span><br><span class="line">c91b90b18884</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">1a51d2f023c9        ubuntu:latest       <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   2 hours ago         Exited (137) 2 hours ago                       gifted_brown</span><br><span class="line">414bf796cbe4        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              2 hours ago         Exited (0) 2 hours ago                         pedantic_galileo</span><br><span class="line">512061ebfa4c        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              2 hours ago         Exited (0) 2 hours ago                         wizardly_brown</span><br><span class="line">aa5e9ae5e5db        ubuntu:latest       <span class="string">&quot;/bin/echo &#x27;Hello wo…&quot;</span>   2 hours ago         Exited (0) 2 hours ago                         affectionate_knuth</span><br></pre></td></tr></table></figure><p>最后再来删除镜像吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker rmi hello-world</span></span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2f</span><br><span class="line">Deleted: sha256:fce289e99eb9bca977dae136fbe2a82b6b7d4c372474c9235adc1741675f587e</span><br><span class="line">Deleted: sha256:af0b15c8625bb1938f1d7b17081031f649fd14e6b233688eea3c5483994a66a3</span><br></pre></td></tr></table></figure><h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><blockquote><p>针对上述ubuntu的镜像，我们能否在里面安装一些软件，然后重新生成一个镜像呢？这就是更新重新commit出一个新的镜像。</p></blockquote><p>我们先跑一个ubuntu容器实例，同时在里面进行<code>apt-get update</code>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker run -it ubuntu:latest</span></span><br><span class="line">root@0a1556ca3c27:/<span class="comment"># apt-get update</span></span><br><span class="line">Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]</span><br><span class="line">Get:2 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]</span><br><span class="line">Get:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]</span><br><span class="line">Get:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB]</span><br><span class="line">Get:5 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [817 kB]</span><br><span class="line">Get:6 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB]</span><br><span class="line">Get:7 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB]</span><br><span class="line">Get:8 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB]</span><br><span class="line">Get:9 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB]</span><br><span class="line">Get:10 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [27.5 kB]</span><br><span class="line">Get:11 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [7064 B]</span><br><span class="line">Get:12 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [818 kB]</span><br><span class="line">Get:13 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [11.1 kB]</span><br><span class="line">Get:14 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [1345 kB]</span><br><span class="line">Get:15 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [41.2 kB]</span><br><span class="line">Get:16 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [1104 kB]</span><br><span class="line">Get:17 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [4252 B]</span><br><span class="line">Get:18 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [2496 B]</span><br><span class="line">Fetched 17.6 MB <span class="keyword">in</span> 10s (1759 kB/s)</span><br><span class="line">Reading package lists... Done</span><br><span class="line">root@0a1556ca3c27:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>此时 ID 为 0a1556ca3c27 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker commit -m=&quot;update test&quot; -a=&quot;pdai&quot; 0a1556ca3c27  pdai/ubuntu:v1.0.1</span></span><br><span class="line">sha256:b51e9f5f98cdb5b95c34181148ed7029f0150618aa8cd0e916b10b6aea1bd4c9</span><br></pre></td></tr></table></figure><p>可以看到已经生成成功, 且镜像的大小不一样了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pdai/ubuntu         v1.0.1              b51e9f5f98cd        5 seconds ago       92.1MB</span><br><span class="line">mysql               latest              791b6e40940c        2 weeks ago         465MB</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br></pre></td></tr></table></figure><h3 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h3><blockquote><p>那如果是生成一个全新的镜像呢？我们使用命令 docker build ，通过创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p></blockquote><p>这里特意指定的Base镜像为上一步修改生成的<code>pdai/ubuntu:v1.0.1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM    pdai/ubuntu:v1.0.1</span><br><span class="line">MAINTAINER      pdai <span class="string">&quot;pdai.tech&quot;</span></span><br><span class="line"></span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     useradd pdai</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;pdai:123456&#x27;</span> |chpasswd</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><ul><li>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</li><li>第一条FROM，指定使用哪个镜像源</li><li>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</li><li>我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</li></ul><p>接下来生成镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai docker-test]<span class="comment"># docker build -t pdai/ubuntu:v2.0.1 .</span></span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/9 : FROM    pdai/ubuntu:v1.0.1</span><br><span class="line"> ---&gt; b51e9f5f98cd</span><br><span class="line">Step 2/9 : MAINTAINER      pdai <span class="string">&quot;pdai.tech&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> af026ee229ea</span><br><span class="line">Removing intermediate container af026ee229ea</span><br><span class="line"> ---&gt; 0e961cb557c9</span><br><span class="line">Step 3/9 : RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 96bd9c40c55e</span><br><span class="line">Removing intermediate container 96bd9c40c55e</span><br><span class="line"> ---&gt; 9e8549720043</span><br><span class="line">Step 4/9 : RUN     useradd pdai</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 0117278f243c</span><br><span class="line">Removing intermediate container 0117278f243c</span><br><span class="line"> ---&gt; 87c478df56da</span><br><span class="line">Step 5/9 : RUN     /bin/<span class="built_in">echo</span> <span class="string">&#x27;pdai:123456&#x27;</span> |chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e0381eabe71a</span><br><span class="line">Removing intermediate container e0381eabe71a</span><br><span class="line"> ---&gt; 84fd07f978ae</span><br><span class="line">Step 6/9 : RUN     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 8d0052d9921f</span><br><span class="line">Removing intermediate container 8d0052d9921f</span><br><span class="line"> ---&gt; 3ed0b248224c</span><br><span class="line">Step 7/9 : EXPOSE  22</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 4b5d540567cd</span><br><span class="line">Removing intermediate container 4b5d540567cd</span><br><span class="line"> ---&gt; c0a72ad140dd</span><br><span class="line">Step 8/9 : EXPOSE  80</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> c9620707d038</span><br><span class="line">Removing intermediate container c9620707d038</span><br><span class="line"> ---&gt; df42b714ecc1</span><br><span class="line">Step 9/9 : CMD     /usr/sbin/sshd -D</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e178826b43fe</span><br><span class="line">Removing intermediate container e178826b43fe</span><br><span class="line"> ---&gt; a733d5a264b5</span><br><span class="line">Successfully built a733d5a264b5</span><br><span class="line">Successfully tagged pdai/ubuntu:v2.0.1</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-t</code> ：指定要创建的目标镜像名</li><li><code>.</code> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li></ul><p>使用docker images 查看创建的镜像已经在列表中存在,镜像ID为a733d5a264b5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai docker-test]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pdai/ubuntu         v2.0.1              a733d5a264b5        5 minutes ago       92.5MB</span><br><span class="line">pdai/ubuntu         v1.0.1              b51e9f5f98cd        15 hours ago        92.1MB</span><br><span class="line">mysql               latest              791b6e40940c        2 weeks ago         465MB</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br></pre></td></tr></table></figure><p>我们可以使用新的镜像来创建容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai docker-test]<span class="comment"># docker run -it pdai/ubuntu:v2.0.1 /bin/bash</span></span><br><span class="line">root@f5332ebce695:/<span class="comment"># id pdai</span></span><br><span class="line">uid=1000(pdai) gid=1000(pdai) groups=1000(pdai)</span><br><span class="line">root@f5332ebce695:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>从上面看到新镜像已经包含我们创建的用户 pdai。</p><h3 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h3><blockquote><p>设置镜像的Tag，类似于Git中tag？我们可以使用 docker tag 命令，为镜像添加一个新的标签</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker tag a733d5a264b5 pdai/ubuntu:v3.0.1</span></span><br><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pdai/ubuntu         v2.0.1              a733d5a264b5        9 minutes ago       92.5MB</span><br><span class="line">pdai/ubuntu         v3.0.1              a733d5a264b5        9 minutes ago       92.5MB</span><br><span class="line">pdai/ubuntu         v1.0.1              b51e9f5f98cd        15 hours ago        92.1MB</span><br><span class="line">mysql               latest              791b6e40940c        2 weeks ago         465MB</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>docker tag 镜像ID，这里是 a733d5a264b5 ,用户名称、镜像源名(repository name)和新的标签名(tag)。</li><li>使用 docker images 命令可以看到，ID为a733d5a264b5的镜像多一个v3.0.1标签。</li></ul><h3 id="镜像导出和导入"><a href="#镜像导出和导入" class="headerlink" title="镜像导出和导入"></a>镜像导出和导入</h3><blockquote><p>区别于容器的导出和导入</p></blockquote><ul><li>镜像导出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">dockREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pdai/ubuntu                  v2.0.2              57544a04cd1a        3 months ago        91.5MB</span><br><span class="line">[root@pdai ~]<span class="comment"># docker save &gt; pdai-ubuntu-v2.0.2.tar 57544a04cd1a</span></span><br><span class="line">[root@pdai ~]<span class="comment"># ll | grep pdai-u</span></span><br><span class="line">-rw-rw-r-- 1 root root 93898240 Jun  4 09:06 pdai-ubuntu-v2.0.2.tar</span><br><span class="line">[root@pdai ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>镜像导入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; pdai-ubuntu-v2.0.2.tar</span><br></pre></td></tr></table></figure><p>其中<code>-i</code>或者<code>&lt;</code>表示从文件输入。会成功导入镜像及相关元数据，包括tag信息</p><blockquote><p>可以依据具体使用场景来选择命令</p></blockquote><ul><li>若是只想备份images，使用save、load即可</li><li>若是在启动容器后，容器内容有变化，需要备份，则使用export、import</li></ul><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><blockquote><p>上面已经展示了部分容器的使用命令了，这里会在此基础上进行拓展</p></blockquote><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><p>首先我们是可以这样启动容器的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai docker-test]<span class="comment"># docker run -it pdai/ubuntu:v2.0.1 /bin/bash</span></span><br><span class="line">root@f5332ebce695:/<span class="comment"># id pdai</span></span><br><span class="line">uid=1000(pdai) gid=1000(pdai) groups=1000(pdai)</span><br><span class="line">root@f5332ebce695:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ul><li><code>-it</code> 可以连写的，表示 <code>-i -t</code></li><li><code>-t</code>: 在新容器内指定一个伪终端或终端。</li><li><code>-i</code>: 允许你对容器内的标准输入 (STDIN) 进行交互</li></ul><h3 id="容器查看"><a href="#容器查看" class="headerlink" title="容器查看"></a>容器查看</h3><ul><li><code>-a</code> 表示 all，所有的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>              20 minutes ago      Exited (0) 20 minutes ago                       jolly_kepler</span><br><span class="line">0a1556ca3c27        ubuntu:latest        <span class="string">&quot;/bin/bash&quot;</span>              16 hours ago        Exited (0) 16 hours ago                         stoic_hodgkin</span><br><span class="line">1a51d2f023c9        ubuntu:latest        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   18 hours ago        Exited (137) 18 hours ago                       gifted_brown</span><br><span class="line">414bf796cbe4        ubuntu:latest        <span class="string">&quot;/bin/bash&quot;</span>              18 hours ago        Exited (0) 18 hours ago                         pedantic_galileo</span><br><span class="line">512061ebfa4c        ubuntu:latest        <span class="string">&quot;/bin/bash&quot;</span>              18 hours ago        Exited (0) 18 hours ago                         wizardly_brown</span><br><span class="line">aa5e9ae5e5db        ubuntu:latest        <span class="string">&quot;/bin/echo &#x27;Hello wo…&quot;</span>   18 hours ago        Exited (0) 18 hours ago                         affectionate_knuth</span><br></pre></td></tr></table></figure><h3 id="容器再启动"><a href="#容器再启动" class="headerlink" title="容器再启动"></a>容器再启动</h3><blockquote><p>我们看到，刚才<code>pdai/ubuntu:v2.0.1</code>的实例<code>f5332ebce695</code>已经停止了<code>Exited (0) 20 minutes ago</code>，我们能否再启这个实例？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker start f5332ebce695</span></span><br><span class="line">f5332ebce695</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>         32 minutes ago      Up 4 seconds        22/tcp, 80/tcp      jolly_kepler</span><br></pre></td></tr></table></figure><h3 id="容器停止和重启"><a href="#容器停止和重启" class="headerlink" title="容器停止和重启"></a>容器停止和重启</h3><blockquote><p>我们将上述容器停止，再重启</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker stop f5332ebce695</span></span><br><span class="line">f5332ebce695</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@pdai ~]<span class="comment"># docker restart f5332ebce695</span></span><br><span class="line">f5332ebce695</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>              33 minutes ago      Up 2 seconds                22/tcp, 80/tcp      jolly_kepler</span><br><span class="line">0a1556ca3c27        ubuntu:latest        <span class="string">&quot;/bin/bash&quot;</span>              16 hours ago        Exited (0) 16 hours ago                         stoic_hodgkin</span><br><span class="line">1a51d2f023c9        ubuntu:latest        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   18 hours ago        Exited (137) 18 hours ago                       gifted_brown</span><br><span class="line">414bf796cbe4        ubuntu:latest        <span class="string">&quot;/bin/bash&quot;</span>              18 hours ago        Exited (0) 18 hours ago                         pedantic_galileo</span><br><span class="line">512061ebfa4c        ubuntu:latest        <span class="string">&quot;/bin/bash&quot;</span>              18 hours ago        Exited (0) 18 hours ago                         wizardly_brown</span><br><span class="line">aa5e9ae5e5db        ubuntu:latest        <span class="string">&quot;/bin/echo &#x27;Hello wo…&quot;</span>   19 hours ago        Exited (0) 19 hours ago                         affectionate_knuth</span><br></pre></td></tr></table></figure><h3 id="后台模式与进入"><a href="#后台模式与进入" class="headerlink" title="后台模式与进入"></a>后台模式与进入</h3><blockquote><p>在使用 -d 参数时，容器启动后会进入后台, 如何进入容器呢？</p></blockquote><ul><li>第一种：<code>docker attach</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>         38 minutes ago      Up 2 seconds        22/tcp, 80/tcp      jolly_kepler</span><br><span class="line">[root@pdai ~]<span class="comment"># docker attach f5332ebce695</span></span><br><span class="line">root@f5332ebce695:/<span class="comment"># echo &#x27;pdai&#x27;</span></span><br><span class="line">pdai</span><br><span class="line">root@f5332ebce695:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>看到没，使用<code>docker attach</code>进入后，exit便容器也停止了。</p><ul><li>第二种：<code>docker exec</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker exec -it f5332ebce695 /bin/bash</span></span><br><span class="line">Error response from daemon: Container f5332ebce69520fba353f035ccddd4bd42055fbd1e595f916ba7233e26476464 is not running</span><br><span class="line">[root@pdai ~]<span class="comment"># docker restart f5332ebce695</span></span><br><span class="line">f5332ebce695</span><br><span class="line">[root@pdai ~]<span class="comment"># docker exec -it f5332ebce695 /bin/bash</span></span><br><span class="line">root@f5332ebce695:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>         42 minutes ago      Up 8 seconds        22/tcp, 80/tcp      jolly_kepler</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>我特意在容器停止状态下执行了<code>docker exec</code>，是让你看到<code>docker exec</code>是在容器启动状态下用的，且注意下错误信息；</li><li>推荐大家使用 <code>docker exec</code> 命令，因为此退出容器终端，不会导致容器的停止。</li></ul><h3 id="容器导出和导入"><a href="#容器导出和导入" class="headerlink" title="容器导出和导入"></a>容器导出和导入</h3><blockquote><p>在生产环境中，很多时候是无法连接外网的，所以有时候需要用到容器的导入和导出。</p></blockquote><ul><li>容器的导出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>         42 minutes ago      Up 8 seconds        22/tcp, 80/tcp      jolly_kepler</span><br><span class="line">[root@pdai ~]<span class="comment"># docker export f5332ebce695 &gt; ubuntu-pdai-v2.tar</span></span><br><span class="line">[root@pdai ~]<span class="comment"># ll</span></span><br><span class="line">-rw-rw-r-- 1 root root 93891072 Feb 18 09:42 ubuntu-pdai-v2.tar</span><br></pre></td></tr></table></figure><p>同时你可以发现，导出容器的时候，容器无需关闭。</p><ul><li>容器导入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker import ubuntu-pdai-v2.tar pdai/ubuntu:v2.0.2</span></span><br><span class="line">sha256:57544a04cd1ad330371ca9142184ff031dc2b6df70df177994477c08fe547b25</span><br><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pdai/ubuntu         v2.0.2              57544a04cd1a        7 seconds ago       91.5MB</span><br><span class="line">pdai/ubuntu         v2.0.1              a733d5a264b5        About an hour ago   92.5MB</span><br><span class="line">pdai/ubuntu         v3.0.1              a733d5a264b5        About an hour ago   92.5MB</span><br><span class="line">pdai/ubuntu         v1.0.1              b51e9f5f98cd        16 hours ago        92.1MB</span><br><span class="line">mysql               latest              791b6e40940c        2 weeks ago         465MB</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br></pre></td></tr></table></figure><p>注意看，SIZE可能是不一样的。</p><h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><blockquote><p>能否强制删除一个正在运行的容器呢？</p></blockquote><p>显然，加上<code>-f</code>之后是允许的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f5332ebce695        pdai/ubuntu:v2.0.1   <span class="string">&quot;/bin/bash&quot;</span>         About an hour ago   Up 24 minutes       22/tcp, 80/tcp      jolly_kepler</span><br><span class="line">[root@pdai ~]<span class="comment"># docker rm -f f5332ebce695</span></span><br><span class="line">f5332ebce695</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">0a1556ca3c27        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              17 hours ago        Exited (0) 17 hours ago                         stoic_hodgkin</span><br><span class="line">1a51d2f023c9        ubuntu:latest       <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   19 hours ago        Exited (137) 19 hours ago                       gifted_brown</span><br><span class="line">414bf796cbe4        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              19 hours ago        Exited (0) 19 hours ago                         pedantic_galileo</span><br><span class="line">512061ebfa4c        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              19 hours ago        Exited (0) 19 hours ago                         wizardly_brown</span><br><span class="line">aa5e9ae5e5db        ubuntu:latest       <span class="string">&quot;/bin/echo &#x27;Hello wo…&quot;</span>   19 hours ago        Exited (0) 19 hours ago                         affectionate_knuth</span><br></pre></td></tr></table></figure><h3 id="清理停止的容器"><a href="#清理停止的容器" class="headerlink" title="清理停止的容器"></a>清理停止的容器</h3><blockquote><p>我们看到上面还有好几个容器出于停止状态，能不能删除它们呢？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">0a1556ca3c27        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              17 hours ago        Exited (0) 17 hours ago                         stoic_hodgkin</span><br><span class="line">1a51d2f023c9        ubuntu:latest       <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   19 hours ago        Exited (137) 19 hours ago                       gifted_brown</span><br><span class="line">414bf796cbe4        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              19 hours ago        Exited (0) 19 hours ago                         pedantic_galileo</span><br><span class="line">512061ebfa4c        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>              19 hours ago        Exited (0) 19 hours ago                         wizardly_brown</span><br><span class="line">aa5e9ae5e5db        ubuntu:latest       <span class="string">&quot;/bin/echo &#x27;Hello wo…&quot;</span>   19 hours ago        Exited (0) 19 hours ago                         affectionate_knuth</span><br></pre></td></tr></table></figure><p>清理停止的容器: <code>docker container prune</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker container prune</span></span><br><span class="line">WARNING! This will remove all stopped containers.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span>? [y/N] y</span><br><span class="line">Deleted Containers:</span><br><span class="line">0a1556ca3c275cc692ecd6d19caed4c5be42578f81b3dfea52b24208790d160a</span><br><span class="line">1a51d2f023c947f2be2d9a78eb863e854ca302c89bf354654c409e23e7dd25d7</span><br><span class="line">414bf796cbe403e01b5414f2b6232c6a037af78deee4581f4935c94859b5164e</span><br><span class="line">512061ebfa4c340eb03833e54d77052e33fb62cd42ab7dd7e09bf0b02a761552</span><br><span class="line">aa5e9ae5e5db1760bdb8c7ddb92e4293cd7b4736be7e97314f3ef44a71bf8930</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 27.93MB</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><h3 id="容器别名及操作"><a href="#容器别名及操作" class="headerlink" title="容器别名及操作"></a>容器别名及操作</h3><blockquote><p>我们上述对容器的操作都是针对容器ID，这个ID是随机的，能否添加一个name对我们自己设置的name操作呢？</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker run -itd --name pdai-ubuntu-202 pdai/ubuntu:v2.0.2 /bin/bash</span></span><br><span class="line">11de9755a08402d963d263a559a7daf48f4a2188398f258641240b5eb50fbc89</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">11de9755a084        pdai/ubuntu:v2.0.2   <span class="string">&quot;/bin/bash&quot;</span>         5 seconds ago       Up 4 seconds                            pdai-ubuntu-202</span><br><span class="line">[root@pdai ~]<span class="comment"># docker stop pdai-ubuntu-202</span></span><br><span class="line">pdai-ubuntu-202</span><br><span class="line">[root@pdai ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                COMMAND              CREATED              STATUS                     PORTS               NAMES</span><br><span class="line">11de9755a084        pdai/ubuntu:v2.0.2   <span class="string">&quot;/bin/bash&quot;</span>          26 seconds ago       Exited (0) 4 seconds ago                       pdai-ubuntu-202   </span><br></pre></td></tr></table></figure><h3 id="容器错误日志"><a href="#容器错误日志" class="headerlink" title="容器错误日志"></a>容器错误日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">例：实时查看docker容器名为user-uat的最后10行日志</span><br><span class="line">docker logs -f -t --tail 10 user-uat</span><br><span class="line"></span><br><span class="line">例：查看指定时间后的日志，只显示最后100行：</span><br><span class="line">docker logs -f -t --since=<span class="string">&quot;2018-02-08&quot;</span> --tail=100 user-uat</span><br><span class="line"></span><br><span class="line">例：查看最近30分钟的日志:</span><br><span class="line">docker logs --since 30m user-uat</span><br><span class="line"></span><br><span class="line">例：查看某时间之后的日志：</span><br><span class="line">docker logs -t --since=<span class="string">&quot;2018-02-08T13:23:37&quot;</span> user-uat</span><br><span class="line"></span><br><span class="line">例：查看某时间段日志：</span><br><span class="line">docker logs -t --since=<span class="string">&quot;2018-02-08T13:23:37&quot;</span> --until <span class="string">&quot;2018-02-09T12:23:37&quot;</span> user-uat</span><br><span class="line"></span><br><span class="line">例：将错误日志写入文件：</span><br><span class="line">docker logs -f -t --since=<span class="string">&quot;2018-02-18&quot;</span> user-uat | grep error &gt;&gt; logs_error.txt</span><br></pre></td></tr></table></figure><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>仓库（Repository）是集中存放镜像的地方，它和我们的Maven仓库是一样的。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</p><ul><li>可以采用共有的仓库，也可以自己搭建Docker Registry;</li><li>如果之前有自己的Artifactory或者Nexus，它们同样可以支持Docker Registry功能;</li><li>带界面的也可以使用Harbor等;</li></ul><h3 id="公有仓库"><a href="#公有仓库" class="headerlink" title="公有仓库"></a>公有仓库</h3><blockquote><p>我们以官方的docker hub为例，进行注册和理解。很多人会说官方的速度极慢或者私有仓库上传慢，不试试你怎么知道呢？</p></blockquote><ul><li><strong>注册官方docker hub</strong>，最新的名字叫docker cloud</li></ul><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>我注册的用户名是 realpdai</p><ul><li><strong>本地登录</strong>刚才注册的账户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker login</span></span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don<span class="string">&#x27;t have a Docker ID, head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="string">Username: realpdai</span></span><br><span class="line"><span class="string">Password:</span></span><br><span class="line"><span class="string">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span></span><br><span class="line"><span class="string">Configure a credential helper to remove this warning. See</span></span><br><span class="line"><span class="string">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Login Succeeded</span></span><br></pre></td></tr></table></figure><ul><li><strong>镜像准备</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker tag pdai/ubuntu:v2.0.2 realpdai/ubuntu:v2.0.2</span></span><br><span class="line">[root@pdai ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pdai/ubuntu         v2.0.2              57544a04cd1a        4 hours ago         91.5MB</span><br><span class="line">realpdai/ubuntu     v2.0.2              57544a04cd1a        4 hours ago         91.5MB</span><br><span class="line">pdai/ubuntu         v2.0.1              a733d5a264b5        5 hours ago         92.5MB</span><br><span class="line">pdai/ubuntu         v3.0.1              a733d5a264b5        5 hours ago         92.5MB</span><br><span class="line">pdai/ubuntu         v1.0.1              b51e9f5f98cd        21 hours ago        92.1MB</span><br><span class="line">mysql               latest              791b6e40940c        2 weeks ago         465MB</span><br><span class="line">ubuntu              latest              ccc6e87d482b        4 weeks ago         64.2MB</span><br></pre></td></tr></table></figure><ul><li>推送至Docker Hub服务器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai ~]<span class="comment"># docker push realpdai/ubuntu:v2.0.2</span></span><br><span class="line">The push refers to repository [docker.io/realpdai/ubuntu]</span><br><span class="line">9a2c43cbe02a: Pushed</span><br><span class="line">v2.0.2: digest: sha256:4afd82dd05d0b4a340ae4f4129dcbd63136b5ec7ff92edf313108a41fb0947e0 size: 528</span><br></pre></td></tr></table></figure><p>从推送的速度来看，大概是1.5MB/s。</p><ul><li>服务器端查看</li></ul><p><img src="https://img.doge.sh.cn/assets/1687850932626RwfHS5cZ.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架『2』</title>
      <link href="/2021/12/10/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E3%80%8E2%E3%80%8F/"/>
      <url>/2021/12/10/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E3%80%8E2%E3%80%8F/</url>
      
        <content type="html"><![CDATA[<p>Map 接口 键值对的集合 （双列集合）<br>├———Hashtable 接口实现类， 同步， 线程安全<br>├———HashMap 接口实现类 ，没有同步， 线程不安全<br>│—————–├ LinkedHashMap 双向链表和哈希表实现<br>│—————–└ WeakHashMap<br>├ ——–TreeMap 红黑树对所有的key进行排序<br>└———IdentifyHashMap</p><span id="more"></span><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashSet-amp-HashMap"><a href="#HashSet-amp-HashMap" class="headerlink" title="HashSet &amp; HashMap"></a>HashSet &amp; HashMap</h3><h4 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>之所以把<code>HashSet</code>和<code>HashMap</code>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<code>HashSet</code>里面有一个<code>HashMap</code>(适配器模式)。因此本文将重点分析<code>HashMap</code>。</p><p><code>HashMa</code>实现<code>Ma</code>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；<code>TreeMa</code>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<code>HashMap</code>的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<code>Java7 HashMap采用的是冲突链表方式</code>。</p><p><img src="https://img.doge.sh.cn/assets/1642474979493YexJwKXW.png" alt="HashMap_base"></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<code>HashMap</code>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<code>HashMap</code>的初始大小设的过大。</p><p>有两个参数可以影响<code>HashMap</code>的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity</code>load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<code>HashMap</code>或<code>HashSet</code>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<code>@Override hashCode()</code>和<code>equals()</code>方法。</p><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。 算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。</p><p><img src="https://img.doge.sh.cn/assets/1642475002815xDB1ksKc.png" alt="HashMap_addEntry"></p><p>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<code>HashMap</code>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//依据equals()方法判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h5><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<code>头插法</code>。</p><p><img src="https://img.doge.sh.cn/assets/16424826804633MaFr8N4.png" alt="HashMap_addEntry"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h5><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>getEntry()</code>过程类似。</p><p><img src="https://img.doge.sh.cn/assets/1642482708817EbrksW6H.png" alt="HashMap_removeEntryForKey"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//removeEntryForKey()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h4><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <code>数组+链表+红黑树</code> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="https://img.doge.sh.cn/assets/1642474787827JjJfcE48.png" alt="img"></p><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h5 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第五个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><h5 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h5><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h5><p>相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(==或equals)的 key</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>前面已经说过<code>HashSet</code>是对<code>HashMap</code>的简单包装，对<code>HashSet</code>的函数调用都会转换成合适的<code>HashMap</code>方法，因此<code>HashSet</code>的实现非常简单，只有不到300行代码。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedHashSet-amp-Map"><a href="#LinkedHashSet-amp-Map" class="headerlink" title="LinkedHashSet&amp;Map"></a>LinkedHashSet&amp;Map</h3><h4 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>如果你已看过前面关于<code>HashSet</code>和<code>HashMap</code>，以及<code>TreeSet</code>和<code>TreeMap</code>的讲解，一定能够想到本文将要讲解的<code>LinkedHashSet</code>和<code>LinkedHashMap</code>其实也是一回事。<code>LinkedHashSet</code>和<code>LinkedHashMap</code>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<code>LinkedHashSet里面有一个LinkedHashMap(适配器模式)</code>。因此本文将重点分析<code>LinkedHashMap</code>。</p><p><code>LinkedHashMap</code>实现了<code>Map</code>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<code>linked list</code>和<code>HashMap</code>的混合体，也就是说它同时满足<code>HashMap</code>和<code>linked list</code>的某些特性。可将<code>LinkedHashMap </code>看作采用 linked list 增强的 HashMap。</p><p><img src="https://img.doge.sh.cn/assets/1642475565104CBMYfk47.png" alt="LinkedHashMap_base.png"></p><p>事实上<code>LinkedHashMap</code>是<code>HashMap</code>的直接子类，<code>二者唯一的区别是</code>LinkedHashMap<code>在</code>HashMap<code>的基础上，采用双向链表(doubly-linked list)的形式将所有</code>entry<code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</code>。上图给出了<code>LinkedHashMap</code>的结构图，主体部分跟<code>HashMap</code>完全一样，多了<code>header</code>指向双向链表的头部(是一个哑元)，<code>该双向链表的迭代顺序就是</code>entry<code>的插入顺序</code>。</p><p>除了可以保迭代历顺序，这种结构还有一个好处 : 迭代<code>LinkedHashMap</code>时不需要像<code>HashMap</code>那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可<code>，也就是说</code>LinkedHashMap<code>的迭代时间就只跟</code>entry<code>的个数相关，而跟</code>table的大小无关。</p><p>有两个参数可以影响<code>LinkedHashMap</code>的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity</code>load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</p><p>通过如下方式可以得到一个跟源<code>Map</code> <code>迭代顺序</code>一样的<code>LinkedHashMap</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</span><br><span class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>出于性能原因，<code>LinkedHashMap</code>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<code>LinkedHashMap</code>包装成(wrapped)同步的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</span><br></pre></td></tr></table></figure><h4 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h4><h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样。</p><h5 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h5><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p><p>注意，这里的<code>插入有两重含义</code>:</p><blockquote><ol><li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol></blockquote><p><img src="https://img.doge.sh.cn/assets/1642475581864566JPaD8.png" alt="LinkedHashMap_addEntry.png"></p><p><code>addEntry()</code>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<code>addBefore()</code>的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只是简单修改相关<code>entry</code>的引用而已。</p><h5 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h5><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>(修改链表的相应引用)。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的<code>删除也有两重含义</code>:</p><blockquote><ol><li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="https://img.doge.sh.cn/assets/1642475597504mskR5rfb.png" alt="LinkedHashMap_removeEntryForKey.png"></p><p><code>removeEntryForKey()</code>对应的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>前面已经说过<code>LinkedHashSet</code>是对<code>LinkedHashMap</code>的简单包装，对<code>LinkedHashSet</code>的函数调用都会转换成合适的<code>LinkedHashMap</code>方法，因此<code>LinkedHashSet</code>的实现非常简单，这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// LinkedHashSet里面有一个LinkedHashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap经典用法"><a href="#LinkedHashMap经典用法" class="headerlink" title="LinkedHashMap经典用法"></a>LinkedHashMap经典用法</h4><p><code>LinkedHashMap</code>除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回<code>true</code>，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet-amp-TreeMap"><a href="#TreeSet-amp-TreeMap" class="headerlink" title="TreeSet &amp; TreeMap"></a>TreeSet &amp; TreeMap</h3><h4 id="总体介绍-1"><a href="#总体介绍-1" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>之所以把<code>TreeSet</code>和<code>TreeMap</code>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<code>TreeSet</code>里面有一个<code>TreeMap</code>(适配器模式)<code>。因此本文将重点分析</code>TreeMap`。</p><p>Java <code>TreeMap</code>实现了<code>SortedMap</code>接口，也就是说会按照<code>key</code>的大小顺序对<code>Map</code>中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。</p><p><strong>TreeMap底层通过红黑树(Red-Black tree)实现</strong>，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><p><img src="https://img.doge.sh.cn/assets/1642476297133WytR7W8C.png" alt="TreeMap_base.png"></p><p>出于性能原因，<code>TreeMap</code>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<code>TreeMap</code>包装成(wrapped)同步的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</span><br></pre></td></tr></table></figure><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree):</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。</p><h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="https://img.doge.sh.cn/assets/1642476319411EJfBd6DF.png" alt="TreeMap_rotateLeft.png"></p><p><code>TreeMap</code>中左旋代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Left</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><p>右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="https://img.doge.sh.cn/assets/16424763468630jN3SDhn.png" alt="TreeMap_rotateRight.png"></p><p><code>TreeMap</code>中右旋代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Right</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h5><p>对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到:</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="https://img.doge.sh.cn/assets/1642476380729raA6e8ny.png" alt="TreeMap_successor.png"></p><p><code>TreeMap</code>中寻找节点后继的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找节点后继函数successor()</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;<span class="comment">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="方法剖析-1"><a href="#方法剖析-1" class="headerlink" title="方法剖析"></a>方法剖析</h4><h5 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h5><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p><p><img src="https://img.doge.sh.cn/assets/164247640497360meaTPF.png" alt="TreeMap_getEntry.png"></p><p>具体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h5><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);<span class="comment">//调整</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的<code>entry</code>并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="https://img.doge.sh.cn/assets/1642476448880paxAjZJ1.png" alt="TreeMap_put.png"></p><p>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="remove-2"><a href="#remove-2" class="headerlink" title="remove()"></a>remove()</h5><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p><code>getEntry()</code>函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的<code>entry</code>并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况:</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。</p><p>基于以上逻辑，红黑树的节点删除函数<code>deleteEntry()</code>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;<span class="comment">// 2. 删除点p的左右子树都非空。</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 1. 删除点p只有一棵子树非空。</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1. 删除点p的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，<strong>无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。</strong></p><p><img src="https://img.doge.sh.cn/assets/1642476487325tNXMBfhG.png" alt="TreeMap_fixAfterDeletion.png"></p><p>上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet是对TreeMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;();<span class="comment">// TreeSet里面有一个TreeMap</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><h4 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h4><blockquote><p>JDK 1.8.0_110</p></blockquote><h4 id="总体介绍-2"><a href="#总体介绍-2" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: <code>WeakHashMap</code>，从名字可以看出它是某种 <code>Map</code>。它的特殊之处在于 <code>WeakHashMap</code> 里的<code>entry</code>可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。</p><p>更直观的说，当使用 <code>WeakHashMap</code> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况:</p><blockquote><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code>；</li><li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管两次使用的是同一个<code>key</code>；</li><li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象。</li></ul></blockquote><p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，<code>WeakHashMap</code> 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p><p>要明白 <code>WeakHashMap</code> 的工作原理，还需要引入一个概念 : <code>弱引用(WeakReference)</code>。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，<code>是否有有效的引用指向该对象</code>。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的<code>有效引用</code> 并不包括<code>弱引用</code>。也就是说，<code>虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</code>。</p><p><code>WeakHashMap</code> 内部是通过弱引用来管理<code>entry</code>的，弱引用的特性对应到 <code>WeakHashMap</code> 上意味着什么呢？将一对<code>key, value</code>放入到 <code>WeakHashMap</code> 里并不能避免该<code>key</code>值被GC回收，除非在 <code>WeakHashMap</code> 之外还有对该<code>key</code>的强引用。</p><p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>WeakHashMap的存储结构类似于HashSet &amp; HashMap ，这里不再赘述。</p><p>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h4 id="Weak-HashSet"><a href="#Weak-HashSet" class="headerlink" title="Weak HashSet?"></a>Weak HashSet?</h4><p>如果你看过前几篇关于 <code>Map</code> 和 <code>Set</code> 的讲解，一定会问: 既然有 <code>WeakHashMap</code>，是否有 <code>WeekHashSet</code> 呢? 答案是没有:( 。不过Java <code>Collections</code>工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 <code>Map</code>包装成一个<code>Set</code>。通过如下方式可以快速得到一个 <code>Weak HashSet</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将WeakHashMap包装成一个Set</span></span><br><span class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</span><br><span class="line">        <span class="keyword">new</span> WeakHashMap&lt;Object, Boolean&gt;());</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>不出你所料，<code>newSetFromMap()</code>方法只是对传入的 <code>Map</code>做了简单包装:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SetFromMap&lt;&gt;(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFromMap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;E, Boolean&gt; m;  <span class="comment">// The backing map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;E&gt; s;       <span class="comment">// Its keySet</span></span><br><span class="line">    SetFromMap(Map&lt;E, Boolean&gt; map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Map is non-empty&quot;</span>);</span><br><span class="line">        m = map;</span><br><span class="line">        s = map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123;        m.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> m.size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> m.isEmpty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> m.containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> m.remove(o) != <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> m.put(e, Boolean.TRUE) == <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray()         &#123; <span class="keyword">return</span> s.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)     &#123; <span class="keyword">return</span> s.toArray(a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> o == <span class="keyword">this</span> || s.equals(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="keyword">return</span> s.containsAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.removeAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.retainAll(c);&#125;</span><br><span class="line">    <span class="comment">// addAll is the only inherited implementation</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架『1』</title>
      <link href="/2021/12/03/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E3%80%8E1%E3%80%8F/"/>
      <url>/2021/12/03/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E3%80%8E1%E3%80%8F/</url>
      
        <content type="html"><![CDATA[<p>Collection 接口的接口 对象的集合（单列集合）<br>├——-List 接口：元素按进入先后有序保存，可重复<br>│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-└ Vector 接口实现类 数组， 同步， 线程安全<br>│ ———————-└ Stack 是Vector类的实现类（不建议使用）<br>└——-Set 接口： 仅接收一次，不可重复，并做内部排序<br>├—————-└HashSet 使用hash表（数组）存储元素<br>│————————└ LinkedHashSet 链表维护元素的插入次序<br>└ —————-TreeSet 底层实现为二叉树，元素排好序</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>​    容器，就是可以容纳其他Java对象的对象。<code>Java Collections Framework(JCF)</code>为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:降低编程难度，提高程序性能，提高API间的互操作性，降低学习难度，降低设计和实现相关API的难度，增加程序的重用性。</p><p>​    Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><blockquote><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 详情见Java 集合框架 （2）</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。详情见Java 集合框架 （2）</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。详情见Java 集合框架 （2）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​    <code>ArrayList</code>实现了<code>List</code>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<code>数组实现</code>。除该类未实现同步外，其余跟<code>Vector</code>大致相同。每个<code>ArrayList</code>都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">add(), addAll()</td><td align="center">这两个方法都是向容器中添加新元素，这可能会导致<code>capacity</code>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。</td></tr><tr><td align="center">set()</td><td align="center">既然底层是一个数组<code>ArrayList</code>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。</td></tr><tr><td align="center">get()</td><td align="center"><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</td></tr><tr><td align="center">remove()</td><td align="center"><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</td></tr><tr><td align="center">trimToSize()</td><td align="center">ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过<code>trimToSize</code>方法来实现。</td></tr><tr><td align="center">indexOf(), lastIndexOf()</td><td align="center">获取元素的第一次或最后一次出现的index:</td></tr></tbody></table><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>和 ArrayList 类似，但它是线程安全的。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​    LinkedList同时实现了<code>List</code>接口和<code>Deque</code>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<code>Queue</code>)，同时又可以看作一个栈(<code>Stack</code>)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用<code>Stack</code>类，更遗憾的是，Java里根本没有一个叫做<code>Queue</code>的类(它是个接口名字)。关于栈或队列，现在的首选是<code>ArrayDeque</code>，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...))</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">getFirst(), getLast()</td><td align="center">获取第一个元素， 和获取最后一个元素:</td></tr><tr><td align="center">removeFirest(), removeLast(), remove(e), remove(index)</td><td align="center"><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</td></tr><tr><td align="center">add()</td><td align="center"><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在LinkedList的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</td></tr><tr><td align="center">addAll()</td><td align="center">addAll(index, c) 实现方式<code>并不是直接调用add(index,e)来实现</code>，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次；</td></tr><tr><td align="center">clear()</td><td align="center">为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。</td></tr><tr><td align="center">indexOf</td><td align="center">查找操作的本质是查找元素的下标:查找第一次出现的index, 如果找不到返回-1；</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>​    Java里有一个叫做<code>Stack</code>的类，却没有叫做<code>Queue</code>的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用<code>Stack</code>，而是推荐使用更高效的<code>ArrayDeque</code>；既然<code>Queue</code>只是一个接口，当需要使用队列时也就首选<code>ArrayDeque</code>了(次选是<code>LinkedList</code>)。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code>接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的<code>insertion</code>, <code>extraction</code>和<code>inspection</code>操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code>是”double ended queue”, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下:</p><table><thead><tr><th></th><th>First Element - Head</th><th></th><th>Last Element - Tail</th><th></th></tr></thead><tbody><tr><td></td><td>Throws exception</td><td>Special value</td><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>Examine</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>当把<code>Deque</code>当做FIFO的<code>queue</code>来使用时，元素是从<code>deque</code>的尾部添加，从头部进行删除的； 所以<code>deque</code>的部分方法是和<code>queue</code>是等同的。具体如下:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p><code>Deque</code>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<code>Deque</code>与<code>Queue</code>相对应的接口:</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<code>Deque</code>与<code>Stack</code>对应的接口:</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p>上面两个表共定义了<code>Deque</code>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(<code>false</code>或<code>null</code>)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然<code>Deque</code>的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。</p><p><code>ArrayDeque</code>和<code>LinkedList</code>是<code>Deque</code>的两个通用实现，由于官方更推荐使用<code>AarryDeque</code>用作栈和队列，加之上一篇已经讲解过<code>LinkedList</code>，本文将着重讲解<code>ArrayDeque</code>的具体实现。</p><p>从名字可以看出<code>ArrayDeque</code>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<code>循环数组(circular array)</code>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><img src="https://img.doge.sh.cn/assets/163895659551771ZnQfDc.png" alt="ArrayDeque_base.png"></p><p>上图中我们看到，<code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>​    前面以Java <code>ArrayDeque</code>为例讲解了<code>Stack</code>和<code>Queue</code>，其实还有一种特殊的队列叫做<code>PriorityQueue</code>，即优先队列。优先队列的作用是能保证每次取出的元素都是<code>队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)</code>。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><p>Java中<code>PriorityQueue</code>实现了<code>Queue</code>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为<code>PriorityQueue</code>的底层实现。</p><p><img src="https://img.doge.sh.cn/assets/16389567813097kKhxKZa.png" alt="PriorityQueue_base.png"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo = parentNo*2+1</span><br><span class="line">rightNo = parentNo*2+2</span><br><span class="line">parentNo = (nodeNo-1)/2</span><br></pre></td></tr></table></figure><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><code>PriorityQueue</code>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<code>log(N)</code>。</p><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">add()和offer()</td><td align="center"><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于PriorityQueue这两个方法其实没什么差别。</td></tr><tr><td align="center">element()和peek()</td><td align="center"><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<code>直接返回数组0下标处的那个元素即可</code>。</td></tr><tr><td align="center">remove()和poll()</td><td align="center"><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</td></tr><tr><td align="center">remove(Object o)</td><td align="center"><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素(如果有多个相等，只删除一个)，该方法不是<code>Queue</code>接口内的方法，而是<code>Collection</code>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA Linux 远程调试</title>
      <link href="/2021/10/13/IDEA-Linux-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
      <url>/2021/10/13/IDEA-Linux-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>​        本文源起于一次线上Bug，代码在本地运行良好但是放到 Linux 主机上却报了错，当时还不会 IDEA 远程调试只能不断的将关键位置的信息存入日志或控制台打印出来，且不停的打包和修改非常让人抓狂🙃 ，百度中发现 IDEA 居然还可以调试 Linux 主机上正在运行的代码，简直就像发现了宝藏，又是一份意想不到的狂喜。🤣🤣🤣!!</p><span id="more"></span><p>​        首先介绍下环境：IDEA 2020.1 , JDK1.8 , 调试主机是运行在Hyper-V 中的 Centos7 主机 项目用的是SpringBoot </p><h1 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h1><p>​        先打开IDEA 最上方的 <code>Run-&gt;Edit Configurations...</code> ，点击左上角的加号选择 <code>Remote JVM Debug</code> 窗口如下。<img src="https://img.doge.sh.cn/assets/1634117993380Jw2SbifS.png" alt="image-20211013173951926" style="zoom:67%;" /></p><p>​        其中Host需要填写你 Linux 主机的地址 Port 填写主机上未被占用的端口号就行，它这里默认是5005 这里我就不动了，再将下面文本框中的参数复制并记录下来，后续部署的时候需要使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><h1 id="Linux配置"><a href="#Linux配置" class="headerlink" title="Linux配置"></a>Linux配置</h1><p>​        将当前代码打成jar包上传到 Linux 后，部署的命令需要插入上面 IDEA  给的参数，如下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -jar 你的jar包名称</span><br></pre></td></tr></table></figure><p>​        若部署出现<code>Listening for transport dt_socket at address: 5005</code> 则表示本次部署打开了调试模式。</p><p>​        至此IDEA选择你刚刚配置的运行项再点击小虫子按钮就可以开始调试啦！<code>要注意本地代码要和服务器上的包相对应哦！</code></p><h1 id="访问问题"><a href="#访问问题" class="headerlink" title="访问问题"></a>访问问题</h1><p>​        如果仍然不行则大概率是端口访问的问题，或者防火墙未关闭，我这里推荐你用 <code>tcping</code> :一个开源的控制台程序，可以用来 ping Linux的端口<img src="https://img.doge.sh.cn/assets/1634180282395dMBc16Je.png" alt="image-20211014105759187"></p><p>​        使用方法也很简单:将 tcping.exe 下载下来 放到 C:\windows\system32  目录下，这样你就可以在CMD中直接使用它啦！</p><p><img src="https://img.doge.sh.cn/assets/1634180626340aBs0CjEZ.png" alt="image-20211014110343029"></p><p>语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcping IP地址 端口号</span><br></pre></td></tr></table></figure><p>CentOS 中你可能用的命令如下：</p><p>Linux查看某个端口是否在运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep 端口号</span><br></pre></td></tr></table></figure><p>查看防火墙状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>暂时关闭防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>永久关闭防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>重启防火墙：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable firewalld</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IDEA </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 开发最容易写的 10 个bug</title>
      <link href="/2021/10/12/Java-%E5%BC%80%E5%8F%91%E6%9C%80%E5%AE%B9%E6%98%93%E5%86%99%E7%9A%84-10-%E4%B8%AAbug/"/>
      <url>/2021/10/12/Java-%E5%BC%80%E5%8F%91%E6%9C%80%E5%AE%B9%E6%98%93%E5%86%99%E7%9A%84-10-%E4%B8%AAbug/</url>
      
        <content type="html"><![CDATA[<p>那个谁，今天又写 bug 了，没错，他说的好像就是我。。。。。。</p><p>作为 Java 开发，我们在写代码的过程中难免会产生各种奇思妙想的 bug ，有些 bug 就挺让人无奈的，比如说各种空指针异常，在 ArrayList 的迭代中进行删除操作引发异常，数组下标越界异常等。</p><span id="more"></span><p>如果你不小心看到同事的代码出现了我所描述的这些 bug 后，那你就把我这篇文章甩给他！！！你甩给他一篇文章，并让他关注了一波 cxuan，你会收获他在后面像是如获至宝并满眼崇拜大神的目光。</p><p>废话不多说，下面进入正题。</p><h2 id="错误一：Array-转换成-ArrayList"><a href="#错误一：Array-转换成-ArrayList" class="headerlink" title="错误一：Array 转换成 ArrayList"></a><strong>错误一：Array 转换成 ArrayList</strong></h2><p>Array 转换成 ArrayList 还能出错？这是哪个笨。。。。。。</p><p>等等，你先别着急说，先来看看是怎么回事。</p><p>如果要将数组转换为 ArrayList，我们一般的做法会是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>Arrays.asList() 将返回一个 ArrayList，它是 Arrays 中的私有静态类，它不是 java.util.ArrayList 类。如下图所示</p><p><img src="https://img.doge.sh.cn/assets/1634026047857yahfYXFz.webp" alt="640"></p><p>Arrays 内部的 ArrayList 只有 set、get、contains 等方法，但是没有能够像是 add 这种能够使其内部结构进行改变的方法，所以 Arrays 内部的 ArrayList 的大小是固定的。</p><p><img src="https://img.doge.sh.cn/assets/1634026103094sxe80DfX.webp" alt="640"></p><p>如果要创建一个能够添加元素的 ArrayList ，你可以使用下面这种创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</span><br></pre></td></tr></table></figure><p>因为 ArrayList 的构造方法是可以接收一个 Collection 集合的，所以这种创建方式是可行的。</p><p><img src="https://img.doge.sh.cn/assets/1634026209073A5NGzYW4.webp" alt="640 (1)"></p><h2 id="错误二：检查数组是否包含某个值"><a href="#错误二：检查数组是否包含某个值" class="headerlink" title="错误二：检查数组是否包含某个值"></a>错误二：检查数组是否包含某个值</h2><p>检查数组中是否包含某个值，部分程序员经常会这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br></pre></td></tr></table></figure><p>这段代码虽然没错，但是有额外的性能损耗，正常情况下，不用将其再转换为 <em>set</em>，直接这么做就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Arrays.asList(arr).contains(targetValue);</span><br></pre></td></tr></table></figure><p>或者使用下面这种方式（穷举法，循环判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"> <span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>上面第一段代码比第二段更具有可读性。</p><h2 id="错误三：在-List-中循环删除元素"><a href="#错误三：在-List-中循环删除元素" class="headerlink" title="错误三：在 List 中循环删除元素"></a>错误三：在 List 中循环删除元素</h2><p>这个错误我相信很多小伙伴都知道了，在循环中删除元素是个禁忌，有段时间内我在审查代码的时候就喜欢看团队的其他小伙伴有没有犯这个错误。</p><p>说到底，为什么不能这么做（集合内删除元素）呢？且看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"> list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>这个输出结果你能想到么？是不是蠢蠢欲动想试一波了？</p><p>答案其实是 [b,d]</p><p>为什么只有两个值？我这不是循环输出的么？</p><p>其实，在列表内部，当你使用<strong>外部</strong> remove 的时候，一旦 remove 一个元素后，其列表的内部结构会发生改变，一开始集合总容量是 4，remove 一个元素之后就会变为 3，然后再和 i 进行比较判断。。。。。。所以只能输出两个元素。</p><p>你可能知道使用迭代器是正确的 remove 元素的方式，你还可能知道 for-each 和 iterator 这种工作方式类似，所以你写下了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line"> <span class="keyword">if</span> (s.equals(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">  list.remove(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你充满自信的 run xxx.main() 方法，结果。。。。。。<em>ConcurrentModificationException</em></p><p>为啥呢？</p><p>那是因为使用 ArrayList 中外部 remove 元素，会造成其内部结构和游标的改变。</p><p>在阿里开发规范上，也有不要在 for-each 循环内对元素进行 remove/add 操作的说明。</p><p><img src="https://img.doge.sh.cn/assets/1634026383494RKxZDS3i.webp" alt="640 (2)"></p><p>所以大家要使用 List 进行元素的添加或者删除操作，一定要使用迭代器进行删除。也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line"> String s = iter.next();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (s.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line">  iter.remove();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.next() 必须在 .remove() 之前调用。在 foreach 循环中，编译器会在删除元素的操作后调用 .next()，导致ConcurrentModificationException。</p><h2 id="错误四：Hashtable-和-HashMap"><a href="#错误四：Hashtable-和-HashMap" class="headerlink" title="错误四：Hashtable 和 HashMap"></a>错误四：Hashtable 和 HashMap</h2><p>这是一条算法方面的规约：按照算法的约定，Hashtable 是数据结构的名称，但是在 Java 中，数据结构的名称是 HashMap，Hashtable 和 HashMap 的主要区别之一就是 Hashtable 是同步的，所以很多时候你不需要 Hashtable ，而是使用 HashMap。</p><h2 id="错误五：使用原始类型的集合"><a href="#错误五：使用原始类型的集合" class="headerlink" title="错误五：使用原始类型的集合"></a>错误五：使用原始类型的集合</h2><p>这是一条泛型方面的约束：</p><p>在 Java 中，原始类型和无界通配符类型很容易混合在一起。以 Set 为例，Set 是原始类型，而 Set&lt;?&gt; 是无界通配符类型。</p><p>比如下面使用原始类型 List 作为参数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list, Object o)</span></span>&#123;</span><br><span class="line"> list.add(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> add(list, <span class="number">10</span>);</span><br><span class="line"> String s = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码会抛出 <em>java.lang.ClassCastException</em> 异常，为啥呢？</p><p>使用原始类型集合是比较危险的，因为原始类型会跳过泛型检查而且不安全，<code>Set、Set&lt;?&gt; 和 Set&lt;Object&gt;</code> 存在巨大的差异，而且泛型在使用中很容易造成类型擦除。</p><p>大家都知道，Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java 的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p><p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM 看到的只是<code>List</code>，而由泛型附加的类型信息对 JVM 是看不到的。Java 编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是 Java 的泛型与 C++ 模板机制实现方式之间的重要区别。</p><p>比如下面这段示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个<code>ArrayList</code>数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过<code>list1</code>对象和<code>list2</code>对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为<code>true</code>。说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型。</p><p>所以，最上面那段代码，把 10 添加到 Object 类型中是完全可以的，然而将 Object 类型的 “10” 转换为 String 类型就会抛出类型转换异常。</p><h2 id="错误六：访问级别问题"><a href="#错误六：访问级别问题" class="headerlink" title="错误六：访问级别问题"></a>错误六：访问级别问题</h2><p>我相信大部分开发在设计 class 或者成员变量的时候，都会简单粗暴的直接声明 <em>public xxx</em>，这是一种糟糕的设计，声明为 public 就很容易赤身裸体，这样对于类或者成员变量来说，都存在一定危险性。</p><h2 id="错误七：ArrayList-和-LinkedList"><a href="#错误七：ArrayList-和-LinkedList" class="headerlink" title="错误七：ArrayList 和 LinkedList"></a>错误七：ArrayList 和 LinkedList</h2><p>哈哈哈，ArrayList 是我见过程序员使用频次最高的工具类，没有之一。</p><p>当开发人员不知道 ArrayList 和 LinkedList 的区别时，他们经常使用 ArrayList（其实实际上，就算知道他们的区别，他们也不用 LinkedList，因为这点性能不值一提），因为看起来 ArrayList 更熟悉。。。。。。</p><p>但是实际上，ArrayList 和 LinkedList 存在巨大的性能差异，简而言之，如果添加/删除操作大量且随机访问操作不是很多，则应首选 LinkedList。如果存在大量的访问操作，那么首选 ArrayList，但是 ArrayList 不适合进行大量的添加/删除操作。</p><h2 id="错误八：可变和不可变"><a href="#错误八：可变和不可变" class="headerlink" title="错误八：可变和不可变"></a>错误八：可变和不可变</h2><p>不可变对象有很多优点，比如简单、安全等。但是不可变对象需要为每个不同的值分配一个单独的对象，对象不具备<strong>复用性</strong>，如果这类对象过多可能会导致垃圾回收的成本很高。在可变和不可变之间进行选择时需要有一个平衡。</p><p>一般来说，可变对象用于避免产生过多的中间对象。比如你要连接大量字符串。如果你使用一个不可变的字符串，你会产生很多可以立即进行垃圾回收的对象。这会浪费 CPU 的时间和精力，使用可变对象是正确的解决方案（例如 StringBuilder）。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"> result = result + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正确选择可变对象还是不可变对象需要慎重抉择。</p><h2 id="错误九：构造函数"><a href="#错误九：构造函数" class="headerlink" title="错误九：构造函数"></a>错误九：构造函数</h2><p>首先看一段代码，分析为什么会编译不通过？</p><p><img src="https://img.doge.sh.cn/assets/1634026571686yt2CtKGS.webp" alt="640 (3)"></p><p>发生此编译错误是因为未定义默认 Super 的构造函数。在 Java 中，如果一个类没有定义构造函数，编译器会默认为该类插入一个默认的无参数构造函数。如果在 Super 类中定义了构造函数，在这种情况下 Super(String s)，编译器将不会插入默认的无参数构造函数。这就是上面 Super 类的情况。</p><p>要想解决这个问题，只需要在 Super 中添加一个无参数的构造函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Super&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误十：到底是使用-“”-还是构造函数"><a href="#错误十：到底是使用-“”-还是构造函数" class="headerlink" title="错误十：到底是使用 “” 还是构造函数"></a>错误十：到底是使用 “” 还是构造函数</h2><p>考虑下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String y = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这两段代码有什么区别吗？</p><p>可能下面这段代码会给出你回答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// True</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// True</span></span><br><span class="line"> </span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(c == d);  <span class="comment">// False</span></span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>这就是一个典型的内存分配问题。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天我给你汇总了一下 Java 开发中常见的 10 个错误，虽然比较简单，但是很容易忽视的问题，细节成就完美，看看你还会不会再犯了，如果再犯，嘿嘿嘿。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 根据合同模板生成文件</title>
      <link href="/2021/09/28/Java-%E6%A0%B9%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/"/>
      <url>/2021/09/28/Java-%E6%A0%B9%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>​        在这里记录一下在工作中遇到的一个问题：将客户提供的合同模板填充数据库中查询出来的数据，然后在合同的页眉添加防伪二维码或水印再提供给客户下载。在写的过程中走了一些弯路，不过好在最后还是成功解决~</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        首先，客户提供的模板非常多有Xls，Xlsx，Docx这三种格式，我首先看了下网上的解决方案：有的是用 Apache POI 包直接来进行读写，当然也有GitHub上大佬封装好的jar包底层也是调用的 Apache POI 包但是操作简化了很多。我这里用到了2个包：<a href="http://deepoove.com/poi-tl/">Poi-tl Documentation</a>，<a href="https://www.kancloud.cn/zhangdaiscott/autopoi/1623954">AutoPoi</a> 其中 AutoPoi 是 Excel  和  Word 都能进行操作的而 Poi-tl 则是专注于操作 Docx 。</p><p>​        因为 AutoPoi 是大部分 Office 文件都能操作的 所以我首先选择使用了它，按照文档上的提示替换好所有模板中的标签的后，测试 Docx 的文件没啥问题，但是 Excel 的文件如果涉及到文件中有多个明细行要写入的时候 文档下面的内容就会错位… 最后我将问题定位到客户提供的模板上，只要将模板中表格的“自动换行” 属性去除掉再导出的文件就正常了✌。</p><p>​        前面提到导出的文件是要添加水印和防伪二维码的，Word 仍然是没有什么问题，只不过 Excel 文件添加水印和防伪二维码非常困难🙃，首先 Excel 是不支持“水印”这个功能的，想要做到类似的网上的方法大致分为2种 ：设置 Excel 的背景图片但是这种方式打印的时候不能将“水印”打印出来，第二种是使用“艺术字”功能程序在 Excel 文件上按照一定的逻辑贴上，这种方法虽然可以打印出来但用户可以轻松的编辑“艺术字”所以也是不可取的，再说说防伪二维码：Excel 在页眉上写一张图片的方法也是非常少的，试了很多大多都不可用。</p><p>​        最后的解决方案是：和客户协商将所有的 Excel 文件都转为Docx文件，后端生成 Jar 包则从 AutoPoi 换为 Poi-tl ，这样就不用去支持Excel 了！🤣🤣   Poi-tl 设置页眉非常方便且语法和 AutoPoi  很相近，稍作修改就能兼容。下面简单说下用法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="将一个普通的值放到文件中"><a href="#将一个普通的值放到文件中" class="headerlink" title="将一个普通的值放到文件中"></a>将一个普通的值放到文件中</h2><p>在后端中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XWPFTemplate template = XWPFTemplate.compile(<span class="string">&quot;template.docx&quot;</span>).render(  </span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, Object&gt;()&#123;&#123;put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Hi, poi-tl Word模板引擎&quot;</span>);&#125;&#125;</span><br><span class="line">);</span><br><span class="line">template.writeAndClose(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.docx&quot;</span>));</span><br></pre></td></tr></table></figure><p>在模板中设置标签&#123;&#123;title&#125;&#125;到对应位置</p><h2 id="将一个表格放到文件中"><a href="#将一个表格放到文件中" class="headerlink" title="将一个表格放到文件中"></a>将一个表格放到文件中</h2><p>后端中需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组装表格列表数据</span></span><br><span class="line">List&lt;Map&lt;String,Object&gt;&gt; detailList=<span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    Map&lt;String,Object&gt; detailMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    detailMap.put(<span class="string">&quot;index&quot;</span>, i+<span class="number">1</span>);<span class="comment">//序号</span></span><br><span class="line">    detailMap.put(<span class="string">&quot;goods&quot;</span>, <span class="string">&quot;商品&quot;</span>+i);<span class="comment">//商品名称</span></span><br><span class="line">    detailList.add(detailMap);</span><br><span class="line">&#125;</span><br><span class="line">HackLoopTableRenderPolicy policy = <span class="keyword">new</span> HackLoopTableRenderPolicy();</span><br><span class="line">Configure config = Configure.newBuilder().bind(<span class="string">&quot;detailList&quot;</span>, policy).build();</span><br><span class="line">XWPFTemplate template = XWPFTemplate.compile(<span class="string">&quot;填写模板地址&quot;</span>, config).render(</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;detailList&quot;</span>, detailList);</span><br><span class="line">        put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Hi, poi-tl Word模板引擎&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line">);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;填写实例化路径&quot;</span>);</span><br><span class="line">template.write(fos);</span><br></pre></td></tr></table></figure><p>模板中需要这样写：</p><p>&#123;&#123;title&#125;&#125;</p><table><thead><tr><th align="center">&#123;&#123;detailList&#125;&#125;序号</th><th align="center">商品名称</th></tr></thead><tbody><tr><td align="center">[index]</td><td align="center">[goods]</td></tr></tbody></table><h2 id="页眉添加防伪二维码"><a href="#页眉添加防伪二维码" class="headerlink" title="页眉添加防伪二维码"></a>页眉添加防伪二维码</h2><p>Poi-tl支持很多格式的图片，我这里用的是 Byte[] 形式的 PNG 二维码图片，生成二维码的 Jar 包很多，这里不再深究。</p><p>后端中需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;picture&quot;</span>,PictureRenderData(<span class="number">50</span>, <span class="number">50</span>, PictureType.PNG, Byte[]形式的PNG对象));</span><br></pre></td></tr></table></figure><p>在模板中图片标签以@开始：&#123;&#123;@picture&#125;&#125;    且只要将&#123;&#123;@picture&#125;&#125;标签放到页眉中就可以做到每页都有防伪二维码的效果！</p><h2 id="模板获取"><a href="#模板获取" class="headerlink" title="模板获取"></a>模板获取</h2><p>如果你的模板在 resource 下，那么我推荐你使用相对位置获取输入流，这样可以防止在 Linux 上部署时找不到模板~✨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream mouldPath = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/templates/1.docx);</span></span><br></pre></td></tr></table></figure><p>打好包的文件如果不能读取或者读取的是损坏的文件那么可能是 Maven 对文件进行了编译导致文件损坏，这时需要在项目根pom文件添加以下过滤内容，其中的nonFilteredFileExtension节点按需填写。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-resources-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xls<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xlsx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>doc<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>docx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>pdf<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="前端下载"><a href="#前端下载" class="headerlink" title="前端下载"></a>前端下载</h2><p>Controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiResult&lt;Boolean&gt; <span class="title">exportDataWord</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        XWPFTemplate template = 填充好数据后返回的XWPFTemplate对象;</span><br><span class="line">        String fileName = <span class="string">&quot;文件名.docx&quot;</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/force-download&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + fileName);</span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        template.write(out);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        template.close();</span><br><span class="line">        <span class="keyword">return</span> ApiResult.result(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue前端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http.request(&#123;</span><br><span class="line">        <span class="attr">url</span>: url,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">showLoading</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">responseType</span>: <span class="string">&quot;blob&quot;</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([res],&#123; <span class="attr">type</span>: <span class="string">&#x27;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#x27;</span>&#125;);</span><br><span class="line">            <span class="keyword">let</span> downloadElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> href = <span class="built_in">window</span>.URL.createObjectURL(blob); <span class="comment">//创建下载的链接</span></span><br><span class="line">            downloadElement.href = href;</span><br><span class="line">            downloadElement.download = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()+<span class="string">&quot;.docx&quot;</span>; <span class="comment">//下载后文件名</span></span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(downloadElement);</span><br><span class="line">            downloadElement.click(); <span class="comment">//点击下载</span></span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(downloadElement); <span class="comment">//下载完成移除元素</span></span><br><span class="line">            <span class="built_in">window</span>.URL.revokeObjectURL(href); <span class="comment">//释放掉blob对象</span></span><br><span class="line">        &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.Query();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>其中 type 参数按需填写</p><table><thead><tr><th align="center">文件后缀</th><th align="center">blob对应的type</th></tr></thead><tbody><tr><td align="center">.doc</td><td align="center">application/msword</td></tr><tr><td align="center">.docx</td><td align="center">application/vnd.openxmlformats-officedocument.wordprocessingml.document</td></tr><tr><td align="center">.xls</td><td align="center">application/vnd.ms-excel</td></tr><tr><td align="center">.xlsx</td><td align="center">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr><tr><td align="center">.txt</td><td align="center">text/plain</td></tr></tbody></table><p>友情提示：如果下载不了可以调试前端看看是不是被$http拦截器给拦截了，并做了其他的处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2021/08/12/Hello%20Hexo/"/>
      <url>/2021/08/12/Hello%20Hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo是一款能将Markdown文件解析成为Html文件的博客，配合GitPage在成本，速度，外观上都有很出色的表现，本文是我使用Hexo的第一篇，意在熟悉Hexo配合freemind主题的样式与配置.</p><span id="more"></span><p><img src="https://img.doge.sh.cn/assets/1628826509768bHc76a2m.png" alt="v2-55d7911a24217554d57c7827c51f06e1_1440w"></p><h1 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>本文使用<a href="https://hexo.io/">Hexo</a> + <a href="https://github.com/">GithubPages</a> + 自建图床</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>《船》</p><p>​    每个人都在挥手，但火车只管往前，因为它别无选择，也因为它不喜欢看人挥手道别。远远地，我看到爷爷转身，沿着他的山向上走去。于是，剩下的只有车厢的摇晃和吱呀声，只有大海的蓝和它上空的海鸥，只有大山的绿和矿场在它身侧划开的深深的伤口。我们什么话都没有，只坐在静默和孤独中。我们来时走了很长的路，所以，还有很长的路要走。                                                                                        </p></blockquote><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><p><strong>加粗</strong>  <em>倾斜</em>  <em><strong>加粗倾斜</strong></em> 重点</p><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><ol><li>这是有序列表1</li><li>这是有序列表2</li><li>这是有序列表3</li></ol><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><ul><li>这是无序列表1</li><li>这是无序列表2</li><li>这是无序列表3</li></ul><h1 id="常用转义符"><a href="#常用转义符" class="headerlink" title="常用转义符"></a>常用转义符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">! &amp;#33; — 惊叹号 Exclamation mark</span><br><span class="line">” &amp;#34; &amp;quot; 双引号 Quotation mark</span><br><span class="line"># &amp;#35; — 数字标志 Number sign</span><br><span class="line">$ &amp;#36; — 美元标志 Dollar sign</span><br><span class="line">% &amp;#37; — 百分号 Percent sign</span><br><span class="line">&amp; &amp;#38; &amp;amp; Ampersand</span><br><span class="line">‘ &amp;#39; — 单引号 Apostrophe</span><br><span class="line">( &amp;#40; — 小括号左边部分 Left parenthesis</span><br><span class="line">) &amp;#41; — 小括号右边部分 Right parenthesis</span><br><span class="line">* &amp;#42; — 星号 Asterisk</span><br><span class="line">+ &amp;#43; — 加号 Plus sign</span><br><span class="line">&lt; &amp;#60; &amp;lt; 小于号 Less than</span><br><span class="line">= &amp;#61; — 等于符号 Equals sign</span><br><span class="line">- &amp;#45; &amp;minus; — 减号</span><br><span class="line">&gt; &amp;#62; &amp;gt; 大于号 Greater than</span><br><span class="line">? &amp;#63; — 问号 Question mark</span><br><span class="line">@ &amp;#64; — Commercial at</span><br><span class="line">[ &amp;#91; --- 中括号左边部分 Left square bracket</span><br><span class="line">\ &amp;#92; --- 反斜杠 Reverse solidus (backslash)</span><br><span class="line">] &amp;#93; — 中括号右边部分 Right square bracket</span><br><span class="line">&#123; &amp;#123; — 大括号左边部分 Left curly brace</span><br><span class="line">| &amp;#124; — 竖线Vertical bar</span><br><span class="line">&#125; &amp;#125; — 大括号右边部分 Right curly brace</span><br></pre></td></tr></table></figure><h1 id="I18N"><a href="#I18N" class="headerlink" title="I18N"></a>I18N</h1><p>もしある種の能力に喜びを感じるのであれば、あなたがその中で最強であって欲しい。</p><p>如果快乐是一种本领的话，那我希望你是那个最厉害的人</p><p>If happiness is a skill, then I hope you are the most powerful person.</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
