<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 开发最容易写的 10 个bug</title>
      <link href="/2021/10/12/Java-%E5%BC%80%E5%8F%91%E6%9C%80%E5%AE%B9%E6%98%93%E5%86%99%E7%9A%84-10-%E4%B8%AAbug/"/>
      <url>/2021/10/12/Java-%E5%BC%80%E5%8F%91%E6%9C%80%E5%AE%B9%E6%98%93%E5%86%99%E7%9A%84-10-%E4%B8%AAbug/</url>
      
        <content type="html"><![CDATA[<p>那个谁，今天又写 bug 了，没错，他说的好像就是我。。。。。。</p><p>作为 Java 开发，我们在写代码的过程中难免会产生各种奇思妙想的 bug ，有些 bug 就挺让人无奈的，比如说各种空指针异常，在 ArrayList 的迭代中进行删除操作引发异常，数组下标越界异常等。</p><span id="more"></span><p>如果你不小心看到同事的代码出现了我所描述的这些 bug 后，那你就把我这篇文章甩给他！！！你甩给他一篇文章，并让他关注了一波 cxuan，你会收获他在后面像是如获至宝并满眼崇拜大神的目光。</p><p>废话不多说，下面进入正题。</p><h2 id="错误一：Array-转换成-ArrayList"><a href="#错误一：Array-转换成-ArrayList" class="headerlink" title="错误一：Array 转换成 ArrayList"></a><strong>错误一：Array 转换成 ArrayList</strong></h2><p>Array 转换成 ArrayList 还能出错？这是哪个笨。。。。。。</p><p>等等，你先别着急说，先来看看是怎么回事。</p><p>如果要将数组转换为 ArrayList，我们一般的做法会是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>Arrays.asList() 将返回一个 ArrayList，它是 Arrays 中的私有静态类，它不是 java.util.ArrayList 类。如下图所示</p><p><img src="https://cdn.59ict.com/assets/1634026047857yahfYXFz.webp" alt="640"></p><p>Arrays 内部的 ArrayList 只有 set、get、contains 等方法，但是没有能够像是 add 这种能够使其内部结构进行改变的方法，所以 Arrays 内部的 ArrayList 的大小是固定的。</p><p><img src="https://cdn.59ict.com/assets/1634026103094sxe80DfX.webp" alt="640"></p><p>如果要创建一个能够添加元素的 ArrayList ，你可以使用下面这种创建方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</span><br></pre></td></tr></table></figure><p>因为 ArrayList 的构造方法是可以接收一个 Collection 集合的，所以这种创建方式是可行的。</p><p><img src="https://cdn.59ict.com/assets/1634026209073A5NGzYW4.webp" alt="640 (1)"></p><h2 id="错误二：检查数组是否包含某个值"><a href="#错误二：检查数组是否包含某个值" class="headerlink" title="错误二：检查数组是否包含某个值"></a>错误二：检查数组是否包含某个值</h2><p>检查数组中是否包含某个值，部分程序员经常会这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br></pre></td></tr></table></figure><p>这段代码虽然没错，但是有额外的性能损耗，正常情况下，不用将其再转换为 <em>set</em>，直接这么做就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Arrays.asList(arr).contains(targetValue);</span><br></pre></td></tr></table></figure><p>或者使用下面这种方式（穷举法，循环判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"> <span class="keyword">if</span>(s.equals(targetValue))</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>上面第一段代码比第二段更具有可读性。</p><h2 id="错误三：在-List-中循环删除元素"><a href="#错误三：在-List-中循环删除元素" class="headerlink" title="错误三：在 List 中循环删除元素"></a>错误三：在 List 中循环删除元素</h2><p>这个错误我相信很多小伙伴都知道了，在循环中删除元素是个禁忌，有段时间内我在审查代码的时候就喜欢看团队的其他小伙伴有没有犯这个错误。</p><p>说到底，为什么不能这么做（集合内删除元素）呢？且看下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"> list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>这个输出结果你能想到么？是不是蠢蠢欲动想试一波了？</p><p>答案其实是 [b,d]</p><p>为什么只有两个值？我这不是循环输出的么？</p><p>其实，在列表内部，当你使用<strong>外部</strong> remove 的时候，一旦 remove 一个元素后，其列表的内部结构会发生改变，一开始集合总容量是 4，remove 一个元素之后就会变为 3，然后再和 i 进行比较判断。。。。。。所以只能输出两个元素。</p><p>你可能知道使用迭代器是正确的 remove 元素的方式，你还可能知道 for-each 和 iterator 这种工作方式类似，所以你写下了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line"> <span class="keyword">if</span> (s.equals(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">  list.remove(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你充满自信的 run xxx.main() 方法，结果。。。。。。<em>ConcurrentModificationException</em></p><p>为啥呢？</p><p>那是因为使用 ArrayList 中外部 remove 元素，会造成其内部结构和游标的改变。</p><p>在阿里开发规范上，也有不要在 for-each 循环内对元素进行 remove/add 操作的说明。</p><p><img src="https://cdn.59ict.com/assets/1634026383494RKxZDS3i.webp" alt="640 (2)"></p><p>所以大家要使用 List 进行元素的添加或者删除操作，一定要使用迭代器进行删除。也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line"> String s = iter.next();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (s.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line">  iter.remove();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.next() 必须在 .remove() 之前调用。在 foreach 循环中，编译器会在删除元素的操作后调用 .next()，导致ConcurrentModificationException。</p><h2 id="错误四：Hashtable-和-HashMap"><a href="#错误四：Hashtable-和-HashMap" class="headerlink" title="错误四：Hashtable 和 HashMap"></a>错误四：Hashtable 和 HashMap</h2><p>这是一条算法方面的规约：按照算法的约定，Hashtable 是数据结构的名称，但是在 Java 中，数据结构的名称是 HashMap，Hashtable 和 HashMap 的主要区别之一就是 Hashtable 是同步的，所以很多时候你不需要 Hashtable ，而是使用 HashMap。</p><h2 id="错误五：使用原始类型的集合"><a href="#错误五：使用原始类型的集合" class="headerlink" title="错误五：使用原始类型的集合"></a>错误五：使用原始类型的集合</h2><p>这是一条泛型方面的约束：</p><p>在 Java 中，原始类型和无界通配符类型很容易混合在一起。以 Set 为例，Set 是原始类型，而 Set&lt;?&gt; 是无界通配符类型。</p><p>比如下面使用原始类型 List 作为参数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list, Object o)</span></span>&#123;</span><br><span class="line"> list.add(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> add(list, <span class="number">10</span>);</span><br><span class="line"> String s = list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码会抛出 <em>java.lang.ClassCastException</em> 异常，为啥呢？</p><p>使用原始类型集合是比较危险的，因为原始类型会跳过泛型检查而且不安全，<code>Set、Set&lt;?&gt; 和 Set&lt;Object&gt;</code> 存在巨大的差异，而且泛型在使用中很容易造成类型擦除。</p><p>大家都知道，Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java 的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p><p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM 看到的只是<code>List</code>，而由泛型附加的类型信息对 JVM 是看不到的。Java 编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是 Java 的泛型与 C++ 模板机制实现方式之间的重要区别。</p><p>比如下面这段示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个<code>ArrayList</code>数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过<code>list1</code>对象和<code>list2</code>对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为<code>true</code>。说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型。</p><p>所以，最上面那段代码，把 10 添加到 Object 类型中是完全可以的，然而将 Object 类型的 “10” 转换为 String 类型就会抛出类型转换异常。</p><h2 id="错误六：访问级别问题"><a href="#错误六：访问级别问题" class="headerlink" title="错误六：访问级别问题"></a>错误六：访问级别问题</h2><p>我相信大部分开发在设计 class 或者成员变量的时候，都会简单粗暴的直接声明 <em>public xxx</em>，这是一种糟糕的设计，声明为 public 就很容易赤身裸体，这样对于类或者成员变量来说，都存在一定危险性。</p><h2 id="错误七：ArrayList-和-LinkedList"><a href="#错误七：ArrayList-和-LinkedList" class="headerlink" title="错误七：ArrayList 和 LinkedList"></a>错误七：ArrayList 和 LinkedList</h2><p>哈哈哈，ArrayList 是我见过程序员使用频次最高的工具类，没有之一。</p><p>当开发人员不知道 ArrayList 和 LinkedList 的区别时，他们经常使用 ArrayList（其实实际上，就算知道他们的区别，他们也不用 LinkedList，因为这点性能不值一提），因为看起来 ArrayList 更熟悉。。。。。。</p><p>但是实际上，ArrayList 和 LinkedList 存在巨大的性能差异，简而言之，如果添加/删除操作大量且随机访问操作不是很多，则应首选 LinkedList。如果存在大量的访问操作，那么首选 ArrayList，但是 ArrayList 不适合进行大量的添加/删除操作。</p><h2 id="错误八：可变和不可变"><a href="#错误八：可变和不可变" class="headerlink" title="错误八：可变和不可变"></a>错误八：可变和不可变</h2><p>不可变对象有很多优点，比如简单、安全等。但是不可变对象需要为每个不同的值分配一个单独的对象，对象不具备<strong>复用性</strong>，如果这类对象过多可能会导致垃圾回收的成本很高。在可变和不可变之间进行选择时需要有一个平衡。</p><p>一般来说，可变对象用于避免产生过多的中间对象。比如你要连接大量字符串。如果你使用一个不可变的字符串，你会产生很多可以立即进行垃圾回收的对象。这会浪费 CPU 的时间和精力，使用可变对象是正确的解决方案（例如 StringBuilder）。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(String s: arr)&#123;</span><br><span class="line"> result = result + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正确选择可变对象还是不可变对象需要慎重抉择。</p><h2 id="错误九：构造函数"><a href="#错误九：构造函数" class="headerlink" title="错误九：构造函数"></a>错误九：构造函数</h2><p>首先看一段代码，分析为什么会编译不通过？</p><p><img src="https://cdn.59ict.com/assets/1634026571686yt2CtKGS.webp" alt="640 (3)"></p><p>发生此编译错误是因为未定义默认 Super 的构造函数。在 Java 中，如果一个类没有定义构造函数，编译器会默认为该类插入一个默认的无参数构造函数。如果在 Super 类中定义了构造函数，在这种情况下 Super(String s)，编译器将不会插入默认的无参数构造函数。这就是上面 Super 类的情况。</p><p>要想解决这个问题，只需要在 Super 中添加一个无参数的构造函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Super&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误十：到底是使用-“”-还是构造函数"><a href="#错误十：到底是使用-“”-还是构造函数" class="headerlink" title="错误十：到底是使用 “” 还是构造函数"></a>错误十：到底是使用 “” 还是构造函数</h2><p>考虑下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String y = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这两段代码有什么区别吗？</p><p>可能下面这段代码会给出你回答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// True</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// True</span></span><br><span class="line"> </span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(c == d);  <span class="comment">// False</span></span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>这就是一个典型的内存分配问题。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天我给你汇总了一下 Java 开发中常见的 10 个错误，虽然比较简单，但是很容易忽视的问题，细节成就完美，看看你还会不会再犯了，如果再犯，嘿嘿嘿。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 根据合同模板生成文件</title>
      <link href="/2021/09/28/Java-%E6%A0%B9%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/"/>
      <url>/2021/09/28/Java-%E6%A0%B9%E6%8D%AE%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>​        在这里记录一下在工作中遇到的一个问题：将客户提供的合同模板填充数据库中查询出来的数据，然后在合同的页眉添加防伪二维码或水印再提供给客户下载。在写的过程中走了一些弯路，不过好在最后还是成功解决~</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        首先，客户提供的模板非常多有Xls，Xlsx，Docx这三种格式，我首先看了下网上的解决方案：有的是用 Apache POI 包直接来进行读写，当然也有GitHub上大佬封装好的jar包底层也是调用的 Apache POI 包但是操作简化了很多。我这里用到了2个包：<a href="http://deepoove.com/poi-tl/">Poi-tl Documentation</a>，<a href="https://www.kancloud.cn/zhangdaiscott/autopoi/1623954">AutoPoi</a> 其中 AutoPoi 是 Excel  和  Word 都能进行操作的而 Poi-tl 则是专注于操作 Docx 。</p><p>​        因为 AutoPoi 是大部分 Office 文件都能操作的 所以我首先选择使用了它，按照文档上的提示替换好所有模板中的标签的后，测试 Docx 的文件没啥问题，但是 Excel 的文件如果涉及到文件中有多个明细行要写入的时候 文档下面的内容就会错位… 最后我将问题定位到客户提供的模板上，只要将模板中表格的“自动换行” 属性去除掉再导出的文件就正常了✌。</p><p>​        前面提到导出的文件是要添加水印和防伪二维码的，Word 仍然是没有什么问题，只不过 Excel 文件添加水印和防伪二维码非常困难🙃，首先 Excel 是不支持“水印”这个功能的，想要做到类似的网上的方法大致分为2种 ：设置 Excel 的背景图片但是这种方式打印的时候不能将“水印”打印出来，第二种是使用“艺术字”功能程序在 Excel 文件上按照一定的逻辑贴上，这种方法虽然可以打印出来但用户可以轻松的编辑“艺术字”所以也是不可取的，再说说防伪二维码：Excel 在页眉上写一张图片的方法也是非常少的，试了很多大多都不可用。</p><p>​        最后的解决方案是：和客户协商将所有的 Excel 文件都转为Docx文件，后端生成 Jar 包则从 AutoPoi 换为 Poi-tl ，这样就不用去支持Excel 了！🤣🤣   Poi-tl 设置页眉非常方便且语法和 AutoPoi  很相近，稍作修改就能兼容。下面简单说下用法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="将一个普通的值放到文件中"><a href="#将一个普通的值放到文件中" class="headerlink" title="将一个普通的值放到文件中"></a>将一个普通的值放到文件中</h2><p>在后端中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XWPFTemplate template = XWPFTemplate.compile(<span class="string">&quot;template.docx&quot;</span>).render(  </span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, Object&gt;()&#123;&#123;put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Hi, poi-tl Word模板引擎&quot;</span>);&#125;&#125;</span><br><span class="line">);</span><br><span class="line">template.writeAndClose(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.docx&quot;</span>));</span><br></pre></td></tr></table></figure><p>在模板中设置标签&#123;&#123;title&#125;&#125;到对应位置</p><h2 id="将一个表格放到文件中"><a href="#将一个表格放到文件中" class="headerlink" title="将一个表格放到文件中"></a>将一个表格放到文件中</h2><p>后端中需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组装表格列表数据</span></span><br><span class="line">List&lt;Map&lt;String,Object&gt;&gt; detailList=<span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    Map&lt;String,Object&gt; detailMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    detailMap.put(<span class="string">&quot;index&quot;</span>, i+<span class="number">1</span>);<span class="comment">//序号</span></span><br><span class="line">    detailMap.put(<span class="string">&quot;goods&quot;</span>, <span class="string">&quot;商品&quot;</span>+i);<span class="comment">//商品名称</span></span><br><span class="line">    detailList.add(detailMap);</span><br><span class="line">&#125;</span><br><span class="line">HackLoopTableRenderPolicy policy = <span class="keyword">new</span> HackLoopTableRenderPolicy();</span><br><span class="line">Configure config = Configure.newBuilder().bind(<span class="string">&quot;detailList&quot;</span>, policy).build();</span><br><span class="line">XWPFTemplate template = XWPFTemplate.compile(<span class="string">&quot;填写模板地址&quot;</span>, config).render(</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;detailList&quot;</span>, detailList);</span><br><span class="line">        put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Hi, poi-tl Word模板引擎&quot;</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line">);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;填写实例化路径&quot;</span>);</span><br><span class="line">template.write(fos);</span><br></pre></td></tr></table></figure><p>模板中需要这样写：</p><p>&#123;&#123;title&#125;&#125;</p><table><thead><tr><th align="center">&#123;&#123;detailList&#125;&#125;序号</th><th align="center">商品名称</th></tr></thead><tbody><tr><td align="center">[index]</td><td align="center">[goods]</td></tr></tbody></table><h2 id="页眉添加防伪二维码"><a href="#页眉添加防伪二维码" class="headerlink" title="页眉添加防伪二维码"></a>页眉添加防伪二维码</h2><p>Poi-tl支持很多格式的图片，我这里用的是 Byte[] 形式的 PNG 二维码图片，生成二维码的 Jar 包很多，这里不再深究。</p><p>后端中需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">&quot;picture&quot;</span>,PictureRenderData(<span class="number">50</span>, <span class="number">50</span>, PictureType.PNG, Byte[]形式的PNG对象));</span><br></pre></td></tr></table></figure><p>在模板中图片标签以@开始：&#123;&#123;@picture&#125;&#125;    且只要将&#123;&#123;@picture&#125;&#125;标签放到页眉中就可以做到每页都有防伪二维码的效果！</p><h2 id="模板获取"><a href="#模板获取" class="headerlink" title="模板获取"></a>模板获取</h2><p>如果你的模板在 resource 下，那么我推荐你使用相对位置获取输入流，这样可以防止在 Linux 上部署时找不到模板~✨</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream mouldPath = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">&quot;/templates/1.docx);</span></span><br></pre></td></tr></table></figure><p>打好包的文件如果不能读取或者读取的是损坏的文件那么可能是 Maven 对文件进行了编译导致文件损坏，这时需要在项目根pom文件添加以下过滤内容，其中的nonFilteredFileExtension节点按需填写。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-resources-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xls<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xlsx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>doc<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>docx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>pdf<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="前端下载"><a href="#前端下载" class="headerlink" title="前端下载"></a>前端下载</h2><p>Controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiResult&lt;Boolean&gt; <span class="title">exportDataWord</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        XWPFTemplate template = 填充好数据后返回的XWPFTemplate对象;</span><br><span class="line">        String fileName = <span class="string">&quot;文件名.docx&quot;</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/force-download&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + fileName);</span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        template.write(out);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        template.close();</span><br><span class="line">        <span class="keyword">return</span> ApiResult.result(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue前端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http.request(&#123;</span><br><span class="line">        <span class="attr">url</span>: url,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">showLoading</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">responseType</span>: <span class="string">&quot;blob&quot;</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([res],&#123; <span class="attr">type</span>: <span class="string">&#x27;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#x27;</span>&#125;);</span><br><span class="line">            <span class="keyword">let</span> downloadElement = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            <span class="keyword">let</span> href = <span class="built_in">window</span>.URL.createObjectURL(blob); <span class="comment">//创建下载的链接</span></span><br><span class="line">            downloadElement.href = href;</span><br><span class="line">            downloadElement.download = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()+<span class="string">&quot;.docx&quot;</span>; <span class="comment">//下载后文件名</span></span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(downloadElement);</span><br><span class="line">            downloadElement.click(); <span class="comment">//点击下载</span></span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(downloadElement); <span class="comment">//下载完成移除元素</span></span><br><span class="line">            <span class="built_in">window</span>.URL.revokeObjectURL(href); <span class="comment">//释放掉blob对象</span></span><br><span class="line">        &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.Query();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>其中 type 参数按需填写</p><table><thead><tr><th align="center">文件后缀</th><th align="center">blob对应的type</th></tr></thead><tbody><tr><td align="center">.doc</td><td align="center">application/msword</td></tr><tr><td align="center">.docx</td><td align="center">application/vnd.openxmlformats-officedocument.wordprocessingml.document</td></tr><tr><td align="center">.xls</td><td align="center">application/vnd.ms-excel</td></tr><tr><td align="center">.xlsx</td><td align="center">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td></tr><tr><td align="center">.txt</td><td align="center">text/plain</td></tr></tbody></table><p>友情提示：如果下载不了可以调试前端看看是不是被$http拦截器给拦截了，并做了其他的处理。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2021/08/12/Hello%20Hexo/"/>
      <url>/2021/08/12/Hello%20Hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo是一款能将Markdown文件解析成为Html文件的博客，配合GitPage在成本，速度，外观上都有很出色的表现，本文是我使用Hexo的第一篇，意在熟悉Hexo配合freemind主题的样式与配置.</p><span id="more"></span><p><img src="https://cdn.59ict.com/assets/1628826509768bHc76a2m.png" alt="v2-55d7911a24217554d57c7827c51f06e1_1440w"></p><h1 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>本文使用<a href="https://hexo.io/">Hexo</a> + <a href="https://github.com/">GithubPages</a> + 自建图床</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>《船》</p><p>​    每个人都在挥手，但火车只管往前，因为它别无选择，也因为它不喜欢看人挥手道别。远远地，我看到爷爷转身，沿着他的山向上走去。于是，剩下的只有车厢的摇晃和吱呀声，只有大海的蓝和它上空的海鸥，只有大山的绿和矿场在它身侧划开的深深的伤口。我们什么话都没有，只坐在静默和孤独中。我们来时走了很长的路，所以，还有很长的路要走。                                                                                        </p></blockquote><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><p><strong>加粗</strong>  <em>倾斜</em>  <em><strong>加粗倾斜</strong></em> 重点</p><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><ol><li>这是有序列表1</li><li>这是有序列表2</li><li>这是有序列表3</li></ol><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><ul><li>这是无序列表1</li><li>这是无序列表2</li><li>这是无序列表3</li></ul><h1 id="常用转义符"><a href="#常用转义符" class="headerlink" title="常用转义符"></a>常用转义符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">! &amp;#33; — 惊叹号 Exclamation mark</span><br><span class="line">” &amp;#34; &amp;quot; 双引号 Quotation mark</span><br><span class="line"># &amp;#35; — 数字标志 Number sign</span><br><span class="line">$ &amp;#36; — 美元标志 Dollar sign</span><br><span class="line">% &amp;#37; — 百分号 Percent sign</span><br><span class="line">&amp; &amp;#38; &amp;amp; Ampersand</span><br><span class="line">‘ &amp;#39; — 单引号 Apostrophe</span><br><span class="line">( &amp;#40; — 小括号左边部分 Left parenthesis</span><br><span class="line">) &amp;#41; — 小括号右边部分 Right parenthesis</span><br><span class="line">* &amp;#42; — 星号 Asterisk</span><br><span class="line">+ &amp;#43; — 加号 Plus sign</span><br><span class="line">&lt; &amp;#60; &amp;lt; 小于号 Less than</span><br><span class="line">= &amp;#61; — 等于符号 Equals sign</span><br><span class="line">- &amp;#45; &amp;minus; — 减号</span><br><span class="line">&gt; &amp;#62; &amp;gt; 大于号 Greater than</span><br><span class="line">? &amp;#63; — 问号 Question mark</span><br><span class="line">@ &amp;#64; — Commercial at</span><br><span class="line">[ &amp;#91; --- 中括号左边部分 Left square bracket</span><br><span class="line">\ &amp;#92; --- 反斜杠 Reverse solidus (backslash)</span><br><span class="line">] &amp;#93; — 中括号右边部分 Right square bracket</span><br><span class="line">&#123; &amp;#123; — 大括号左边部分 Left curly brace</span><br><span class="line">| &amp;#124; — 竖线Vertical bar</span><br><span class="line">&#125; &amp;#125; — 大括号右边部分 Right curly brace</span><br></pre></td></tr></table></figure><h1 id="I18N"><a href="#I18N" class="headerlink" title="I18N"></a>I18N</h1><p>もしある種の能力に喜びを感じるのであれば、あなたがその中で最強であって欲しい。</p><p>如果快乐是一种本领的话，那我希望你是那个最厉害的人</p><p>If happiness is a skill, then I hope you are the most powerful person.</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
